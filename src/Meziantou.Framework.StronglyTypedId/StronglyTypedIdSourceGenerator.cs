using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using Meziantou.Framework.CodeDom;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Operations;
using Microsoft.CodeAnalysis.Text;

namespace Meziantou.Framework.StronglyTypedId
{
    [Generator]
    public sealed class StronglyTypedIdSourceGenerator : ISourceGenerator
    {
        // Possible improvements
        // 
        // - XmlSerializer / NewtonsoftJsonConvert / MongoDbConverter / Elaticsearch / YamlConverter
        // - TypeConverter / IConvertible

        private static readonly DiagnosticDescriptor s_unsuportedType = new(
            id: "MFSTID0001",
            title: "Not support type",
            messageFormat: "The type '{0}' is not supported.",
            category: "StronglyTypedId",
            DiagnosticSeverity.Error,
            isEnabledByDefault: true);

        public void Initialize(GeneratorInitializationContext context)
        {
            context.RegisterForSyntaxNotifications(() => new Receiver());
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Usage", "MA0101:String contains an implicit end of line character", Justification = "Not important")]
        public void Execute(GeneratorExecutionContext context)
        {
            context.AddSource("StronglyTypedIdAttribute.g.cs", SourceText.From(@"
// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//
//      Changes to this file may cause incorrect behavior and will be lost if
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------

[System.Diagnostics.Conditional(""StronglyTypedId_Debug"")]
[System.AttributeUsage(System.AttributeTargets.Struct | System.AttributeTargets.Property)]
internal sealed class StronglyTypedIdAttribute : System.Attribute
{
    public StronglyTypedIdAttribute(System.Type idType) { }
}
", Encoding.UTF8));

            foreach (var stronglyTypeStruct in GetStructs(context))
            {
                var idType = stronglyTypeStruct.AttributeInfo.IdType;
                if (!IsValidType(context.Compilation, idType))
                {
                    context.ReportDiagnostic(Diagnostic.Create(s_unsuportedType, stronglyTypeStruct.AttributeInfo.AttributeSyntax.GetLocation(), idType));
                    continue;
                }

                var codeUnit = new CompilationUnit
                {
                    NullableContext = CodeDom.NullableContext.Enable,
                };

                var structDeclaration = CreateStruct(codeUnit, stronglyTypeStruct);
                GenerateStructMembers(structDeclaration, context.Compilation, stronglyTypeStruct);
                GenerateSystemTextJsonConvert(structDeclaration, context.Compilation, idType);
                var result = codeUnit.ToCsharpString();
                context.AddSource(stronglyTypeStruct.Name + ".g.cs", SourceText.From(result, Encoding.UTF8));
            }
        }

        private static List<StronglyTypedStruct> GetStructs(GeneratorExecutionContext context)
        {
            var result = new List<StronglyTypedStruct>();

            var receiver = (Receiver?)context.SyntaxReceiver;
            Debug.Assert(receiver != null);

            foreach (var structDeclaration in receiver.Structs)
            {
                var semanticModel = context.Compilation.GetSemanticModel(structDeclaration.SyntaxTree);
                var symbol = semanticModel.GetDeclaredSymbol(structDeclaration, context.CancellationToken);
                Debug.Assert(symbol != null);

                var attributeInfo = GetAttributeInfo(context, semanticModel, structDeclaration.AttributeLists);
                if (attributeInfo == null)
                    continue;

                result.Add(new(symbol.ContainingSymbol, symbol, symbol.Name, attributeInfo));
            }

            return result;
        }

        private static AttributeInfo? GetAttributeInfo(GeneratorExecutionContext context, SemanticModel semanticModel, SyntaxList<AttributeListSyntax> attributes)
        {
            foreach (var attributeList in attributes)
            {
                foreach (var attribute in attributeList.Attributes)
                {
                    if (attribute.Name is not IdentifierNameSyntax identifierNameSyntax)
                        continue;

                    var name = identifierNameSyntax.Identifier.Text;
                    if (name != "StronglyTypedId" && name != "StronglyTypedIdAttribute")
                        continue;

                    if (attribute.ArgumentList == null)
                        continue;

                    var arguments = attribute.ArgumentList.Arguments;
                    var operation = semanticModel.GetOperation(arguments[0].Expression, context.CancellationToken);
                    if (operation is ITypeOfOperation idTypeOperation && idTypeOperation.TypeOperand != null)
                        return new AttributeInfo(attribute, idTypeOperation.TypeOperand);
                }
            }

            return null;
        }

        private static bool IsValidType(Compilation compilation, ITypeSymbol symbol)
        {
            var types = new List<string>
            {
                "System.Boolean",
                "System.Byte",
                "System.DateTime",
                "System.DateTimeOffset",
                "System.Decimal",
                "System.Double",
                "System.Guid",
                "System.Int16",
                "System.Int32",
                "System.Int64",
                "System.SByte",
                "System.Single",
                "System.String",
                "System.UInt16",
                "System.UInt32",
                "System.UInt64",
            };

            foreach (var type in types)
            {
                var typeSymbol = compilation.GetTypeByMetadataName(type);
                if (SymbolEqualityComparer.Default.Equals(symbol, typeSymbol))
                    return true;
            }

            return false;
        }

        private static StructDeclaration CreateStruct(CompilationUnit unit, StronglyTypedStruct source)
        {
            var structDeclaration = new StructDeclaration(source.Name) { Modifiers = Modifiers.Partial };
            TypeDeclaration root = structDeclaration;

            var containingSymbol = source.ContainingSymbol;
            while (containingSymbol != null)
            {
                if (containingSymbol is ITypeSymbol typeSymbol)
                {
                    TypeDeclaration typeDeclaration = typeSymbol.IsValueType ? new StructDeclaration() : new ClassDeclaration();
                    typeDeclaration.Name = typeSymbol.Name;
                    typeDeclaration.Modifiers = Modifiers.Partial;

                    ((ITypeDeclarationContainer)typeDeclaration).AddType(root);
                    root = typeDeclaration;
                }
                else if (containingSymbol is INamespaceSymbol nsSymbol)
                {
                    var ns = GetNamespace(nsSymbol);
                    if (ns == null)
                    {
                        unit.AddType(root);
                    }
                    else
                    {
                        var namespaceDeclation = new NamespaceDeclaration(ns);
                        namespaceDeclation.AddType(root);
                        unit.AddNamespace(namespaceDeclation);
                    }

                    break;
                }
                else
                {
                    throw new InvalidOperationException($"Symbol '{containingSymbol}' of type '{containingSymbol.GetType().FullName}' not expected");
                }

                containingSymbol = containingSymbol.ContainingSymbol;
            }

            return structDeclaration;
        }

        private static string? GetNamespace(INamespaceSymbol ns)
        {
            string? str = null;
            while (ns != null && !ns.IsGlobalNamespace)
            {
                if (str != null)
                {
                    str = '.' + str;
                }

                str = ns.Name + str;
                ns = ns.ContainingNamespace;
            }

            return str;
        }

        private static bool IsPartial(StructDeclarationSyntax syntax)
        {
            foreach (var modifier in syntax.Modifiers)
            {
                if (modifier.IsKind(SyntaxKind.PartialKeyword))
                    return true;
            }

            return false;
        }

        private static void GenerateStructMembers(StructDeclaration structDeclaration, Compilation compilation, StronglyTypedStruct stronglyTypedStruct)
        {
            var idType = stronglyTypedStruct.AttributeInfo.IdType;
            var typeReference = new TypeReference(idType.ToDisplayString());
            var shortName = idType.Name;
            var isNullable = idType.IsReferenceType;

            // Field
            var valueField = structDeclaration.AddMember(new FieldDeclaration("_value", typeReference) { Modifiers = Modifiers.Private | Modifiers.ReadOnly });

            // Value
            var valueProperty = structDeclaration.AddMember(new PropertyDeclaration("Value", typeReference) { Modifiers = Modifiers.Public });
            valueProperty.Getter = new PropertyAccessorDeclaration(new ReturnStatement(valueField));

            // ctor
            var constructor = structDeclaration.AddMember(new ConstructorDeclaration { Modifiers = Modifiers.Private });
            var constructorArg = constructor.Arguments.Add(typeReference, "value");
            constructor.Statements = new StatementCollection { new AssignStatement(valueField, constructorArg) };

            // From
            var fromMethod = structDeclaration.AddMember(new MethodDeclaration("From" + shortName) { Modifiers = Modifiers.Public | Modifiers.Static });
            fromMethod.ReturnType = structDeclaration;
            var fromMethodArg = fromMethod.Arguments.Add(typeReference, "value");
            fromMethod.Statements = new StatementCollection { new ReturnStatement(new NewObjectExpression(structDeclaration, fromMethodArg)) };

            // ToString
            if (!stronglyTypedStruct.IsToStringDefined())
            {
                var toStringMethod = structDeclaration.AddMember(new MethodDeclaration("ToString") { Modifiers = Modifiers.Public | Modifiers.Override });
                toStringMethod.ReturnType = typeof(string);
                if (isNullable)
                {
                    toStringMethod.Statements = new StatementCollection
                    {
                        new ConditionStatement()
                        {
                            Condition = new BinaryExpression(BinaryOperator.Equals, valueProperty, LiteralExpression.Null()),
                            TrueStatements = new ReturnStatement(new LiteralExpression("")),
                            FalseStatements = new ReturnStatement(new MethodInvokeExpression(new MemberReferenceExpression(valueProperty, "ToString"))),
                        },
                    };
                }
                else
                {
                    toStringMethod.Statements = new StatementCollection
                    {
                        new ReturnStatement(new MethodInvokeExpression(new MemberReferenceExpression(valueProperty, "ToString"))),
                    };
                }
            }

            // if Guid => New
            if (SymbolEqualityComparer.Default.Equals(idType, compilation.GetTypeByMetadataName("System.Guid")))
            {
                var newMethod = structDeclaration.AddMember(new MethodDeclaration("New") { Modifiers = Modifiers.Public | Modifiers.Static });
                newMethod.ReturnType = structDeclaration;
                newMethod.Statements = new StatementCollection { new ReturnStatement(new NewObjectExpression(structDeclaration, new MethodInvokeExpression(new MemberReferenceExpression(typeof(Guid), nameof(Guid.NewGuid))))) };
            }

            // GetHashCode
            if (!stronglyTypedStruct.IsGetHashcodeDefined())
            {
                var getHashCodeMethod = structDeclaration.AddMember(new MethodDeclaration("GetHashCode") { Modifiers = Modifiers.Public | Modifiers.Override });
                getHashCodeMethod.ReturnType = typeof(int);
                if (isNullable)
                {
                    getHashCodeMethod.Statements = new StatementCollection
                    {
                        new ConditionStatement()
                        {
                            Condition = new BinaryExpression(BinaryOperator.Equals, valueProperty, LiteralExpression.Null()),
                            TrueStatements = new ReturnStatement(new LiteralExpression(0)),
                            FalseStatements = new ReturnStatement(new MethodInvokeExpression(new MemberReferenceExpression(valueProperty, "GetHashCode"))),
                        },
                    };
                }
                else
                {
                    getHashCodeMethod.Statements = new StatementCollection
                    {
                        new ReturnStatement(new MethodInvokeExpression(new MemberReferenceExpression(valueProperty, "GetHashCode"))),
                    };
                }
            }

            // IEquatable<T>
            structDeclaration.Implements.Add(new TypeReference(typeof(IEquatable<>)).MakeGeneric(structDeclaration));
            if (!stronglyTypedStruct.IsIEquatableEqualsDefined())
            {
                var equalsTypedMethod = structDeclaration.AddMember(new MethodDeclaration("Equals") { Modifiers = Modifiers.Public });
                equalsTypedMethod.ReturnType = typeof(bool);
                var equalsTypedMethodArg = equalsTypedMethod.Arguments.Add(structDeclaration, "other");
                equalsTypedMethod.Statements = new StatementCollection
                {
                    new ReturnStatement(
                        new MethodInvokeExpression(
                            new MemberReferenceExpression(typeof(object), "Equals"),
                            valueProperty,
                            new MemberReferenceExpression(equalsTypedMethodArg, valueProperty))),
                };
            }

            // Equals
            if (!stronglyTypedStruct.IsEqualsDefined())
            {
                var equalsMethod = structDeclaration.AddMember(new MethodDeclaration("Equals") { Modifiers = Modifiers.Public | Modifiers.Override });
                equalsMethod.ReturnType = typeof(bool);
                var equalsMethodArg = equalsMethod.Arguments.Add(new TypeReference(typeof(object)).MakeNullable(), "other");
                equalsMethod.Statements = new StatementCollection
                {
                    new ConditionStatement()
                    {
                        Condition = new IsInstanceOfTypeExpression(equalsMethodArg, structDeclaration),
                        TrueStatements = new ReturnStatement(new MethodInvokeExpression(new MemberReferenceExpression(new ThisExpression(), "Equals"), new CastExpression(equalsMethodArg, structDeclaration))),
                        FalseStatements = new ReturnStatement(LiteralExpression.False()),
                    },
                };
            }

            // Operator ==
            if (!stronglyTypedStruct.IsOpEqualsDefined())
            {
                var equalsOperatorMethod = structDeclaration.AddMember(new OperatorDeclaration("==") { Modifiers = Modifiers.Public | Modifiers.Static });
                equalsOperatorMethod.ReturnType = typeof(bool);
                var equalsOperatorMethodArg1 = equalsOperatorMethod.Arguments.Add(structDeclaration, "a");
                var equalsOperatorMethodArg2 = equalsOperatorMethod.Arguments.Add(structDeclaration, "b");
                equalsOperatorMethod.Statements.Add(
                    new ReturnStatement(
                        new MethodInvokeExpression(
                            new MemberReferenceExpression(new MemberReferenceExpression(new TypeReference(typeof(EqualityComparer<>)).MakeGeneric(structDeclaration), "Default"), "Equals"),
                            equalsOperatorMethodArg1,
                            equalsOperatorMethodArg2)));
            }

            // Operator !=
            if (!stronglyTypedStruct.IsOpNotEqualsDefined())
            {
                var notEqualsOperatorMethod = structDeclaration.AddMember(new OperatorDeclaration("!=") { Modifiers = Modifiers.Public | Modifiers.Static });
                notEqualsOperatorMethod.ReturnType = typeof(bool);
                var notEqualsOperatorMethodArg1 = notEqualsOperatorMethod.Arguments.Add(structDeclaration, "a");
                var notEqualsOperatorMethodArg2 = notEqualsOperatorMethod.Arguments.Add(structDeclaration, "b");
                notEqualsOperatorMethod.Statements.Add(
                    new ReturnStatement(
                        new UnaryExpression(UnaryOperator.Not,
                            new BinaryExpression(BinaryOperator.Equals, notEqualsOperatorMethodArg1, notEqualsOperatorMethodArg2))));
            }
        }

        private static void GenerateSystemTextJsonConvert(StructDeclaration structDeclaration, Compilation compilation, ITypeSymbol idType)
        {
            var type = compilation.GetTypeByMetadataName("System.Text.Json.Serialization.JsonConverter`1");
            if (type == null)
                return;

            var converter = structDeclaration.AddType(new ClassDeclaration(structDeclaration.Name + "JsonConverter") { Modifiers = Modifiers.Private | Modifiers.Partial });
            structDeclaration.CustomAttributes.Add(new CustomAttribute(new TypeReference("System.Text.Json.Serialization.JsonConverterAttribute")) { Arguments = { new CustomAttributeArgument(new TypeOfExpression(converter)) } });
            converter.BaseType = new TypeReference("System.Text.Json.Serialization.JsonConverter").MakeGeneric(structDeclaration);

            // public abstract void Write (System.Text.Json.Utf8JsonWriter writer, T value, System.Text.Json.JsonSerializerOptions options);
            {
                var writeMethod = converter.AddMember(new MethodDeclaration("Write") { Modifiers = Modifiers.Public | Modifiers.Override });
                var writerArg = writeMethod.AddArgument("writer", new TypeReference("System.Text.Json.Utf8JsonWriter"));
                var valueArg = writeMethod.AddArgument("value", structDeclaration);
                var optionsArg = writeMethod.AddArgument("options", new TypeReference("System.Text.Json.JsonSerializerOptions"));

                if (idType.SpecialType == SpecialType.System_Boolean)
                {
                    writeMethod.Statements = new StatementCollection
                    {
                        new MethodInvokeExpression(
                            new MemberReferenceExpression(writerArg, "WriteBooleanValue"),
                            new MemberReferenceExpression(valueArg, "Value")),
                    };
                }
                else if (CanUseWriteNumberValue())
                {
                    writeMethod.Statements = new StatementCollection
                    {
                        new MethodInvokeExpression(
                            new MemberReferenceExpression(writerArg, "WriteNumberValue"),
                            new MemberReferenceExpression(valueArg, "Value")),
                    };
                }
                else if (CanUseWriteNumberValueWithCastToInt())
                {
                    writeMethod.Statements = new StatementCollection
                    {
                        new MethodInvokeExpression(
                            new MemberReferenceExpression(writerArg, "WriteNumberValue"),
                            new CastExpression(new MemberReferenceExpression(valueArg, "Value"), typeof(int))),
                    };
                }
                else if (CanUseWriteNumberValueWithCastToUInt())
                {
                    writeMethod.Statements = new StatementCollection
                    {
                        new MethodInvokeExpression(
                            new MemberReferenceExpression(writerArg, "WriteNumberValue"),
                            new CastExpression(new MemberReferenceExpression(valueArg, "Value"), typeof(uint))),
                    };
                }
                else if (CanUseWriteStringValue())
                {
                    writeMethod.Statements = new StatementCollection
                    {
                        new MethodInvokeExpression(
                            new MemberReferenceExpression(writerArg, "WriteStringValue"),
                            new MemberReferenceExpression(valueArg, "Value")),
                    };
                }
                else
                {
                    // JsonSerializer.Serialize(writer, value.Value, options)
                    writeMethod.Statements = new StatementCollection
                    {
                        new MethodInvokeExpression(
                            new MemberReferenceExpression(new TypeReference("System.Text.Json.JsonSerializer"), "Serialize"),
                            writerArg,
                            new MemberReferenceExpression(valueArg, "Value"),
                            optionsArg),
                    };
                }

                bool CanUseWriteNumberValue()
                {
                    return idType.SpecialType == SpecialType.System_Decimal
                        || idType.SpecialType == SpecialType.System_Double
                        || idType.SpecialType == SpecialType.System_Int32
                        || idType.SpecialType == SpecialType.System_Int64
                        || idType.SpecialType == SpecialType.System_Single
                        || idType.SpecialType == SpecialType.System_UInt32
                        || idType.SpecialType == SpecialType.System_UInt64;
                }

                bool CanUseWriteNumberValueWithCastToInt()
                {
                    return idType.SpecialType == SpecialType.System_Int16
                        || idType.SpecialType == SpecialType.System_SByte;
                }

                bool CanUseWriteNumberValueWithCastToUInt()
                {
                    return idType.SpecialType == SpecialType.System_Byte
                        || idType.SpecialType == SpecialType.System_UInt16;
                }

                bool CanUseWriteStringValue()
                {
                    return idType.SpecialType == SpecialType.System_DateTime
                        || SymbolEqualityComparer.Default.Equals(idType, compilation.GetTypeByMetadataName("System.DateTimeOffset"))
                        || SymbolEqualityComparer.Default.Equals(idType, compilation.GetTypeByMetadataName("System.Guid"))
                        || idType.SpecialType == SpecialType.System_String;
                }
            }

            // public override T Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
            {
                var readMethod = converter.AddMember(new MethodDeclaration("Read") { Modifiers = Modifiers.Public | Modifiers.Override });
                readMethod.ReturnType = structDeclaration;
                var readerArg = readMethod.AddArgument("reader", new TypeReference("System.Text.Json.Utf8JsonReader"), Direction.InOut);
                _ = readMethod.AddArgument("typeToConvert", typeof(Type));
                _ = readMethod.AddArgument("options", new TypeReference("System.Text.Json.JsonSerializerOptions"));

                readMethod.Statements = new StatementCollection();
                var valueVariable = readMethod.Statements.Add(new VariableDeclarationStatement(structDeclaration, "value", new DefaultValueExpression(structDeclaration)));
                readMethod.Statements.Add(new ConditionStatement
                {
                    Condition = CompareTokenType(BinaryOperator.Equals, "StartObject"),
                    TrueStatements = CreateObjectParsing(),
                    FalseStatements = ReadValue(),
                });

                readMethod.Statements.Add(new ReturnStatement(valueVariable));

                BinaryExpression CompareTokenType(BinaryOperator op, string tokenType)
                {
                    return new BinaryExpression(
                        op,
                        readerArg.CreateMemberReferenceExpression("TokenType"),
                        new MemberReferenceExpression(new TypeReference("System.Text.Json.JsonTokenType"), tokenType));
                }

                StatementCollection CreateObjectParsing()
                {
                    var statements = new StatementCollection();
                    var valueRead = statements.Add(new VariableDeclarationStatement(typeof(bool), "valueRead", LiteralExpression.False()));
                    statements.Add(ReaderRead());
                    statements.Add(new WhileStatement()
                    {
                        Condition = CompareTokenType(BinaryOperator.NotEquals, "EndObject"),
                        Body = new StatementCollection
                        {
                            new ConditionStatement()
                            {
                                Condition = BinaryExpression.And(
                                    UnaryExpression.Not(valueRead),
                                    CompareTokenType(BinaryOperator.Equals, "PropertyName"),
                                    readerArg.CreateMemberReferenceExpression("ValueTextEquals").CreateInvokeMethodExpression(new LiteralExpression("Value"))),
                                TrueStatements = new StatementCollection
                                {
                                    ReaderRead(),
                                    ReadValue(),
                                    new AssignStatement(valueRead, LiteralExpression.True()),
                                    ReaderRead(),
                                },
                                FalseStatements = new StatementCollection
                                {
                                    ReaderSkip(),
                                    ReaderRead(),
                                },
                            },
                        },
                    });
                    return statements;
                }

                Statement ReaderRead()
                {
                    return new MethodInvokeExpression(readerArg.CreateMemberReferenceExpression("Read"));
                }

                Statement ReaderSkip()
                {
                    return new MethodInvokeExpression(readerArg.CreateMemberReferenceExpression("Skip"));
                }

                Statement ReadValue()
                {
                    return
                        new AssignStatement(
                            valueVariable,
                            new NewObjectExpression(
                                structDeclaration,
                                new MethodInvokeExpression(new MemberReferenceExpression(readerArg, "Get" + idType.Name))));
                }
            }
        }

        private record StronglyTypedStruct(ISymbol ContainingSymbol, ITypeSymbol? ExistingStructSymbol, string Name, AttributeInfo AttributeInfo)
        {
            public bool IsToStringDefined()
            {
                return ExistingStructSymbol != null && ExistingStructSymbol.GetMembers(nameof(ToString)).OfType<IMethodSymbol>()
                    .Any(m => !m.IsStatic && m.Parameters.Length == 0 && m.ReturnType?.SpecialType == SpecialType.System_String);
            }

            public bool IsGetHashcodeDefined()
            {
                return ExistingStructSymbol != null && ExistingStructSymbol.GetMembers(nameof(GetHashCode)).OfType<IMethodSymbol>()
                    .Any(m => !m.IsStatic && m.Parameters.Length == 0 && m.ReturnType?.SpecialType == SpecialType.System_Int32);
            }

            public bool IsEqualsDefined()
            {
                return ExistingStructSymbol != null && ExistingStructSymbol.GetMembers(nameof(Equals)).OfType<IMethodSymbol>()
                    .Any(m => !m.IsStatic && m.Parameters.Length == 1 && m.Parameters[0].Type.SpecialType == SpecialType.System_Object && m.ReturnType?.SpecialType == SpecialType.System_Boolean);
            }

            public bool IsIEquatableEqualsDefined()
            {
                return ExistingStructSymbol != null && ExistingStructSymbol.GetMembers(nameof(Equals)).OfType<IMethodSymbol>()
                    .Any(m => !m.IsStatic && m.Parameters.Length == 1 && SymbolEqualityComparer.Default.Equals(ExistingStructSymbol, m.Parameters[0].Type) && m.ReturnType?.SpecialType == SpecialType.System_Boolean);
            }

            public bool IsOpEqualsDefined()
            {
                return ExistingStructSymbol != null && ExistingStructSymbol.GetMembers("op_Equality").OfType<IMethodSymbol>()
                    .Any(m => m.IsStatic && m.Parameters.Length == 2 && SymbolEqualityComparer.Default.Equals(ExistingStructSymbol, m.Parameters[0].Type) && SymbolEqualityComparer.Default.Equals(ExistingStructSymbol, m.Parameters[1].Type) && m.ReturnType?.SpecialType == SpecialType.System_Boolean);
            }

            public bool IsOpNotEqualsDefined()
            {
                return ExistingStructSymbol != null && ExistingStructSymbol.GetMembers("op_Inequality").OfType<IMethodSymbol>()
                    .Any(m => m.IsStatic && m.Parameters.Length == 2 && SymbolEqualityComparer.Default.Equals(ExistingStructSymbol, m.Parameters[0].Type) && SymbolEqualityComparer.Default.Equals(ExistingStructSymbol, m.Parameters[1].Type) && m.ReturnType?.SpecialType == SpecialType.System_Boolean);
            }
        }

        private record AttributeInfo(AttributeSyntax AttributeSyntax, ITypeSymbol IdType);

        private sealed class Receiver : ISyntaxReceiver
        {
            public List<StructDeclarationSyntax> Structs { get; } = new();

            public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
            {
                if (syntaxNode.IsKind(SyntaxKind.StructDeclaration))
                {
                    Structs.Add((StructDeclarationSyntax)syntaxNode);
                }
            }
        }
    }
}
