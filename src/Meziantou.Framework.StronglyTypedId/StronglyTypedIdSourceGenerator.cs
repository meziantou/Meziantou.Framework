using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.Linq;
using System.Text;
using Meziantou.Framework.CodeDom;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Operations;
using Microsoft.CodeAnalysis.Text;

namespace Meziantou.Framework.StronglyTypedId
{
    [Generator]
    public sealed class StronglyTypedIdSourceGenerator : ISourceGenerator
    {
        // Possible improvements
        // 
        // - XmlSerializer / NewtonsoftJsonConvert / MongoDbConverter / Elaticsearch / YamlConverter
        // - TypeConverter / IConvertible

        private const string FieldName = "_value";
        private const string PropertyName = "Value";
        private const string PropertyAsStringName = "ValueAsString";

        private static readonly DiagnosticDescriptor s_unsuportedType = new(
            id: "MFSTID0001",
            title: "Not support type",
            messageFormat: "The type '{0}' is not supported.",
            category: "StronglyTypedId",
            DiagnosticSeverity.Error,
            isEnabledByDefault: true);

        public void Initialize(GeneratorInitializationContext context)
        {
            context.RegisterForSyntaxNotifications(() => new Receiver());
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Usage", "MA0101:String contains an implicit end of line character", Justification = "Not important")]
        public void Execute(GeneratorExecutionContext context)
        {
            context.AddSource("StronglyTypedIdAttribute.g.cs", SourceText.From(@"
// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//
//      Changes to this file may cause incorrect behavior and will be lost if
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------

[System.Diagnostics.Conditional(""StronglyTypedId_Attributes"")]
[System.AttributeUsage(System.AttributeTargets.Struct | System.AttributeTargets.Class)]
internal sealed class StronglyTypedIdAttribute : System.Attribute
{
    public StronglyTypedIdAttribute(System.Type idType) { }
}
", Encoding.UTF8));

            foreach (var stronglyTypeType in GetTypes(context))
            {
                var codeUnit = new CompilationUnit
                {
                    NullableContext = CodeDom.NullableContext.Enable,
                };

                var structDeclaration = CreateType(codeUnit, stronglyTypeType);
                GenerateTypeMembers(context.Compilation, structDeclaration, stronglyTypeType);
                GenerateTypeConverter(structDeclaration, context.Compilation, stronglyTypeType.AttributeInfo.IdType);
                GenerateSystemTextJsonConverter(structDeclaration, context.Compilation, stronglyTypeType.AttributeInfo.IdType);
                GenerateNewtonsoftJsonConverter(structDeclaration, context.Compilation, stronglyTypeType.AttributeInfo.IdType);
                var result = codeUnit.ToCsharpString();
                context.AddSource(stronglyTypeType.Name + ".g.cs", SourceText.From(result, Encoding.UTF8));
            }
        }

        private static List<StronglyTypedType> GetTypes(GeneratorExecutionContext context)
        {
            var result = new List<StronglyTypedType>();

            var receiver = (Receiver?)context.SyntaxReceiver;
            Debug.Assert(receiver != null);

            foreach (var typeDeclaration in receiver.Types)
            {
                var semanticModel = context.Compilation.GetSemanticModel(typeDeclaration.SyntaxTree);
                var symbol = semanticModel.GetDeclaredSymbol(typeDeclaration, context.CancellationToken);
                Debug.Assert(symbol != null);

                var attributeInfo = GetAttributeInfo(context, semanticModel, typeDeclaration.AttributeLists);
                if (attributeInfo == null)
                    continue;

                result.Add(new(symbol.ContainingSymbol, symbol, symbol.Name, attributeInfo, typeDeclaration));
            }

            return result;
        }

        private static AttributeInfo? GetAttributeInfo(GeneratorExecutionContext context, SemanticModel semanticModel, SyntaxList<AttributeListSyntax> attributes)
        {
            foreach (var attributeList in attributes)
            {
                foreach (var attribute in attributeList.Attributes)
                {
                    if (attribute.Name is not IdentifierNameSyntax identifierNameSyntax)
                        continue;

                    var name = identifierNameSyntax.Identifier.Text;
                    if (name != "StronglyTypedId" && name != "StronglyTypedIdAttribute")
                        continue;

                    if (attribute.ArgumentList == null)
                        continue;

                    var arguments = attribute.ArgumentList.Arguments;
                    var operation = semanticModel.GetOperation(arguments[0].Expression, context.CancellationToken);
                    if (operation is ITypeOfOperation idTypeOperation && idTypeOperation.TypeOperand != null)
                    {
                        var idType = GetIdType(semanticModel.Compilation, idTypeOperation.TypeOperand);
                        if (idType != null)
                            return new AttributeInfo(attribute, idType.Value, idTypeOperation.TypeOperand);

                        context.ReportDiagnostic(Diagnostic.Create(s_unsuportedType, attribute.GetLocation(), idTypeOperation.TypeOperand));
                    }
                }
            }

            return null;
        }

        private static IdType? GetIdType(Compilation compilation, ITypeSymbol symbol)
        {
            if (SymbolEqualityComparer.Default.Equals(symbol, compilation.GetTypeByMetadataName("System.Boolean")))
                return IdType.System_Boolean;

            if (SymbolEqualityComparer.Default.Equals(symbol, compilation.GetTypeByMetadataName("System.Byte")))
                return IdType.System_Byte;

            if (SymbolEqualityComparer.Default.Equals(symbol, compilation.GetTypeByMetadataName("System.DateTime")))
                return IdType.System_DateTime;

            if (SymbolEqualityComparer.Default.Equals(symbol, compilation.GetTypeByMetadataName("System.DateTimeOffset")))
                return IdType.System_DateTimeOffset;

            if (SymbolEqualityComparer.Default.Equals(symbol, compilation.GetTypeByMetadataName("System.Decimal")))
                return IdType.System_Decimal;

            if (SymbolEqualityComparer.Default.Equals(symbol, compilation.GetTypeByMetadataName("System.Double")))
                return IdType.System_Double;

            if (SymbolEqualityComparer.Default.Equals(symbol, compilation.GetTypeByMetadataName("System.Guid")))
                return IdType.System_Guid;

            if (SymbolEqualityComparer.Default.Equals(symbol, compilation.GetTypeByMetadataName("System.Int16")))
                return IdType.System_Int16;

            if (SymbolEqualityComparer.Default.Equals(symbol, compilation.GetTypeByMetadataName("System.Int32")))
                return IdType.System_Int32;

            if (SymbolEqualityComparer.Default.Equals(symbol, compilation.GetTypeByMetadataName("System.Int64")))
                return IdType.System_Int64;

            if (SymbolEqualityComparer.Default.Equals(symbol, compilation.GetTypeByMetadataName("System.SByte")))
                return IdType.System_SByte;

            if (SymbolEqualityComparer.Default.Equals(symbol, compilation.GetTypeByMetadataName("System.Single")))
                return IdType.System_Single;

            if (SymbolEqualityComparer.Default.Equals(symbol, compilation.GetTypeByMetadataName("System.String")))
                return IdType.System_String;

            if (SymbolEqualityComparer.Default.Equals(symbol, compilation.GetTypeByMetadataName("System.UInt16")))
                return IdType.System_UInt16;

            if (SymbolEqualityComparer.Default.Equals(symbol, compilation.GetTypeByMetadataName("System.UInt32")))
                return IdType.System_UInt32;

            if (SymbolEqualityComparer.Default.Equals(symbol, compilation.GetTypeByMetadataName("System.UInt64")))
                return IdType.System_UInt64;

            return null;
        }

        private static TypeReference GetTypeReference(IdType type)
        {
            return type switch
            {
                IdType.System_Boolean => new TypeReference(typeof(bool)),
                IdType.System_Byte => new TypeReference(typeof(byte)),
                IdType.System_DateTime => new TypeReference(typeof(DateTime)),
                IdType.System_DateTimeOffset => new TypeReference(typeof(DateTimeOffset)),
                IdType.System_Decimal => new TypeReference(typeof(decimal)),
                IdType.System_Double => new TypeReference(typeof(double)),
                IdType.System_Guid => new TypeReference(typeof(Guid)),
                IdType.System_Int16 => new TypeReference(typeof(short)),
                IdType.System_Int32 => new TypeReference(typeof(int)),
                IdType.System_Int64 => new TypeReference(typeof(long)),
                IdType.System_SByte => new TypeReference(typeof(sbyte)),
                IdType.System_Single => new TypeReference(typeof(float)),
                IdType.System_String => new TypeReference(typeof(string)),
                IdType.System_UInt16 => new TypeReference(typeof(ushort)),
                IdType.System_UInt32 => new TypeReference(typeof(uint)),
                IdType.System_UInt64 => new TypeReference(typeof(ulong)),
                _ => throw new ArgumentException("Type not supported", nameof(type)),
            };
        }

        private static bool IsNullable(IdType idType)
        {
            return idType == IdType.System_String;
        }

        private static string GetShortName(TypeReference typeReference)
        {
            var index = typeReference.ClrFullTypeName.LastIndexOf('.');
            return typeReference.ClrFullTypeName[(index + 1)..];
        }

        private static ClassOrStructDeclaration CreateType(CompilationUnit unit, StronglyTypedType source)
        {
            TypeDeclaration result = source switch
            {
                { IsClass: true } => new ClassDeclaration(source.Name) { Modifiers = Modifiers.Partial },
                { IsRecord: true } => new RecordDeclaration(source.Name) { Modifiers = Modifiers.Partial },
                _ => new StructDeclaration(source.Name) { Modifiers = Modifiers.Partial },
            };

            var root = result;

            var containingSymbol = source.ContainingSymbol;
            while (containingSymbol != null)
            {
                if (containingSymbol is ITypeSymbol typeSymbol)
                {
                    TypeDeclaration typeDeclaration = typeSymbol.IsValueType ? new StructDeclaration() : new ClassDeclaration();
                    typeDeclaration.Name = typeSymbol.Name;
                    typeDeclaration.Modifiers = Modifiers.Partial;

                    ((ClassOrStructDeclaration)typeDeclaration).AddType(root);
                    root = typeDeclaration;
                }
                else if (containingSymbol is INamespaceSymbol nsSymbol)
                {
                    var ns = GetNamespace(nsSymbol);
                    if (ns == null)
                    {
                        unit.AddType(root);
                    }
                    else
                    {
                        var namespaceDeclation = new NamespaceDeclaration(ns);
                        namespaceDeclation.AddType(root);
                        unit.AddNamespace(namespaceDeclation);
                    }

                    break;
                }
                else
                {
                    throw new InvalidOperationException($"Symbol '{containingSymbol}' of type '{containingSymbol.GetType().FullName}' not expected");
                }

                containingSymbol = containingSymbol.ContainingSymbol;
            }

            return (ClassOrStructDeclaration)result;
        }

        private static string? GetNamespace(INamespaceSymbol ns)
        {
            string? str = null;
            while (ns != null && !ns.IsGlobalNamespace)
            {
                if (str != null)
                {
                    str = '.' + str;
                }

                str = ns.Name + str;
                ns = ns.ContainingNamespace;
            }

            return str;
        }

        private static bool IsPartial(StructDeclarationSyntax syntax)
        {
            foreach (var modifier in syntax.Modifiers)
            {
                if (modifier.IsKind(SyntaxKind.PartialKeyword))
                    return true;
            }

            return false;
        }

        private static void GenerateTypeMembers(Compilation compilation, ClassOrStructDeclaration structDeclaration, StronglyTypedType stronglyTypedStruct)
        {
            var idType = stronglyTypedStruct.AttributeInfo.IdType;
            var typeReference = GetTypeReference(idType);
            var shortName = GetShortName(typeReference);

            // Field
            if (!stronglyTypedStruct.IsFieldDefined())
            {
                _ = structDeclaration.AddMember(new FieldDeclaration(FieldName, typeReference) { Modifiers = Modifiers.Private | Modifiers.ReadOnly });
            }

            // Value
            if (!stronglyTypedStruct.IsValueDefined())
            {
                var valuePropertyDeclaration = structDeclaration.AddMember(new PropertyDeclaration(PropertyName, typeReference) { Modifiers = Modifiers.Public });
                valuePropertyDeclaration.Getter = new PropertyAccessorDeclaration(new ReturnStatement(new MemberReferenceExpression(new ThisExpression(), FieldName)));
            }

            // ValueAsString
            if (!stronglyTypedStruct.IsValueAsStringDefined())
            {
                var valueAsStringProperty = structDeclaration.AddMember(new PropertyDeclaration(PropertyAsStringName, typeof(string)) { Modifiers = Modifiers.Public });
                valueAsStringProperty.Getter = new PropertyAccessorDeclaration(new ReturnStatement(ValueToStringExpression()));
            }

            MemberReferenceExpression CreateValuePropertyRef() => new(new ThisExpression(), PropertyName);
            MemberReferenceExpression CreateValueAsStringPropertyRef() => new(new ThisExpression(), PropertyAsStringName);

            Expression ValueToStringExpression()
            {
                var valueProperty = CreateValuePropertyRef();
                if (idType == IdType.System_String)
                    return valueProperty;

                if (idType == IdType.System_Boolean || idType == IdType.System_Guid)
                    return valueProperty.Member("ToString").InvokeMethod();

                if (idType == IdType.System_DateTime)
                    return valueProperty.Member("ToString").InvokeMethod("o", Expression.Member(typeof(CultureInfo), nameof(CultureInfo.InvariantCulture)));

                if (idType == IdType.System_DateTimeOffset)
                    return valueProperty.Member("UtcDateTime").Member("ToString").InvokeMethod("o", Expression.Member(typeof(CultureInfo), nameof(CultureInfo.InvariantCulture)));

                return valueProperty.Member("ToString").InvokeMethod(Expression.Member(typeof(CultureInfo), nameof(CultureInfo.InvariantCulture)));
            }

            // ctor
            if (!stronglyTypedStruct.IsCtorDefined())
            {
                var constructor = structDeclaration.AddMember(new ConstructorDeclaration { Modifiers = Modifiers.Private });
                var constructorArg = constructor.Arguments.Add(typeReference, "value");
                constructor.Statements = new StatementCollection { new AssignStatement(new MemberReferenceExpression(new ThisExpression(), FieldName), constructorArg) };
            }

            // From
            var fromMethod = structDeclaration.AddMember(new MethodDeclaration("From" + shortName) { Modifiers = Modifiers.Public | Modifiers.Static });
            fromMethod.ReturnType = structDeclaration;
            var fromMethodArg = fromMethod.Arguments.Add(typeReference, "value");
            fromMethod.Statements = new StatementCollection { new ReturnStatement(new NewObjectExpression(structDeclaration, fromMethodArg)) };

            // ToString
            if (!stronglyTypedStruct.IsToStringDefined())
            {
                var toStringMethod = structDeclaration.AddMember(new MethodDeclaration("ToString") { Modifiers = Modifiers.Public | Modifiers.Override });
                toStringMethod.ReturnType = typeof(string);
                if (IsNullable(idType))
                {
                    toStringMethod.Statements = new ConditionStatement
                    {
                        Condition = Expression.EqualsNull(CreateValuePropertyRef()),
                        TrueStatements = new ReturnStatement(structDeclaration.Name + " { Value = <null> }"),
                        FalseStatements = new ReturnStatement(Expression.Add(structDeclaration.Name + " { Value = ", CreateValueAsStringPropertyRef(), " }")),
                    };
                }
                else
                {
                    toStringMethod.Statements = new ReturnStatement(Expression.Add(structDeclaration.Name + " { Value = ", CreateValueAsStringPropertyRef(), " }"));
                }
            }

            // if Guid => New
            if (idType == IdType.System_Guid)
            {
                var newMethod = structDeclaration.AddMember(new MethodDeclaration("New") { Modifiers = Modifiers.Public | Modifiers.Static });
                newMethod.ReturnType = structDeclaration;
                newMethod.Statements = new StatementCollection { new ReturnStatement(new NewObjectExpression(structDeclaration, new MethodInvokeExpression(new MemberReferenceExpression(typeof(Guid), nameof(Guid.NewGuid))))) };
            }

            // GetHashCode
            if (!stronglyTypedStruct.IsGetHashcodeDefined())
            {
                var getHashCodeMethod = structDeclaration.AddMember(new MethodDeclaration("GetHashCode") { Modifiers = Modifiers.Public | Modifiers.Override });
                getHashCodeMethod.ReturnType = typeof(int);
                if (IsNullable(idType))
                {
                    getHashCodeMethod.Statements = new ConditionStatement
                    {
                        Condition = Expression.EqualsNull(CreateValuePropertyRef()),
                        TrueStatements = new ReturnStatement(0),
                        FalseStatements = new ReturnStatement(CreateValuePropertyRef().Member("GetHashCode").InvokeMethod()),
                    };
                }
                else
                {
                    getHashCodeMethod.Statements = new ReturnStatement(CreateValuePropertyRef().Member("GetHashCode").InvokeMethod());
                }
            }

            // IEquatable<T>
            structDeclaration.Implements.Add(new TypeReference(typeof(IEquatable<>)).MakeGeneric(structDeclaration));
            if (!stronglyTypedStruct.IsIEquatableEqualsDefined())
            {
                var equalsTypedMethod = structDeclaration.AddMember(new MethodDeclaration("Equals") { Modifiers = Modifiers.Public });
                equalsTypedMethod.ReturnType = typeof(bool);

                var equalsTypedMethodArg = equalsTypedMethod.Arguments.Add(structDeclaration, "other");
                equalsTypedMethod.Statements = new StatementCollection
                {
                    new ReturnStatement(new BinaryExpression(BinaryOperator.Equals, CreateValuePropertyRef(), new MemberReferenceExpression(equalsTypedMethodArg, "Value"))),
                };

                if (stronglyTypedStruct.IsReferenceType)
                {
                    equalsTypedMethodArg.Type = equalsTypedMethodArg.Type?.MakeNullable();
                    equalsTypedMethod.Statements.Insert(0, new ConditionStatement
                    {
                        Condition = Expression.ReferenceEqualsNull(equalsTypedMethodArg),
                        TrueStatements = new ReturnStatement(Expression.False()),
                    });
                }
            }

            // Equals
            if (!stronglyTypedStruct.IsEqualsDefined())
            {
                var equalsMethod = structDeclaration.AddMember(new MethodDeclaration("Equals") { Modifiers = Modifiers.Public | Modifiers.Override });
                equalsMethod.ReturnType = typeof(bool);
                var equalsMethodArg = equalsMethod.Arguments.Add(new TypeReference(typeof(object)).MakeNullable(), "other");
                equalsMethod.Statements = new StatementCollection
                {
                    new ConditionStatement()
                    {
                        Condition = new IsInstanceOfTypeExpression(equalsMethodArg, structDeclaration),
                        TrueStatements = new ReturnStatement(new MethodInvokeExpression(new ThisExpression().Member("Equals"), new CastExpression(equalsMethodArg, structDeclaration))),
                        FalseStatements = new ReturnStatement(Expression.False()),
                    },
                };
            }

            // Operator ==
            if (!stronglyTypedStruct.IsOpEqualsDefined())
            {
                var equalsOperatorMethod = structDeclaration.AddMember(new OperatorDeclaration("==") { Modifiers = Modifiers.Public | Modifiers.Static });
                equalsOperatorMethod.ReturnType = typeof(bool);
                var equalsOperatorMethodArg1 = equalsOperatorMethod.Arguments.Add(structDeclaration, "a");
                var equalsOperatorMethodArg2 = equalsOperatorMethod.Arguments.Add(structDeclaration, "b");
                if (stronglyTypedStruct.IsReferenceType)
                {
                    equalsOperatorMethodArg1.Type = equalsOperatorMethodArg1.Type?.MakeNullable();
                    equalsOperatorMethodArg2.Type = equalsOperatorMethodArg2.Type?.MakeNullable();
                }

                equalsOperatorMethod.Statements.Add(
                    new ReturnStatement(
                        new MethodInvokeExpression(
                            new MemberReferenceExpression(new MemberReferenceExpression(new TypeReference(typeof(EqualityComparer<>)).MakeGeneric(structDeclaration), "Default"), "Equals"),
                            equalsOperatorMethodArg1,
                            equalsOperatorMethodArg2)));
            }

            // Operator !=
            if (!stronglyTypedStruct.IsOpNotEqualsDefined())
            {
                var notEqualsOperatorMethod = structDeclaration.AddMember(new OperatorDeclaration("!=") { Modifiers = Modifiers.Public | Modifiers.Static });
                notEqualsOperatorMethod.ReturnType = typeof(bool);
                var notEqualsOperatorMethodArg1 = notEqualsOperatorMethod.Arguments.Add(structDeclaration, "a");
                var notEqualsOperatorMethodArg2 = notEqualsOperatorMethod.Arguments.Add(structDeclaration, "b");
                if (stronglyTypedStruct.IsReferenceType)
                {
                    notEqualsOperatorMethodArg1.Type = notEqualsOperatorMethodArg1.Type?.MakeNullable();
                    notEqualsOperatorMethodArg2.Type = notEqualsOperatorMethodArg2.Type?.MakeNullable();
                }

                notEqualsOperatorMethod.Statements.Add(
                    new ReturnStatement(
                        new UnaryExpression(UnaryOperator.Not,
                            new BinaryExpression(BinaryOperator.Equals, notEqualsOperatorMethodArg1, notEqualsOperatorMethodArg2))));
            }

            // Parse / TryParse
            // Check if we can add Span<char> overloads
            var valueTypes = new List<TypeReference>() { new TypeReference(typeof(string)) };
            var readOnlySpan = compilation.GetTypeByMetadataName("System.ReadOnlySpan`1");
            var charSymbol = compilation.GetTypeByMetadataName("System.Char");
            var idTypeReference = GetTypeReference(idType);
            if (readOnlySpan != null && charSymbol != null && idTypeReference.TypeName != null)
            {
                if (compilation.GetTypeByMetadataName(idTypeReference.TypeName)?.GetMembers("TryParse").OfType<IMethodSymbol>()
                        .Any(m => m.Parameters.Length > 0 && SymbolEqualityComparer.Default.Equals(m.Parameters[0].Type, readOnlySpan.Construct(charSymbol))) == true)
                {
                    valueTypes.Add(new TypeReference(typeof(ReadOnlySpan<char>)));
                }
            }

            foreach (var valueType in valueTypes)
            {
                // Parse
                if (!stronglyTypedStruct.IsParseDefined())
                {
                    var parseMethod = structDeclaration.AddMember(new MethodDeclaration("Parse") { Modifiers = Modifiers.Public | Modifiers.Static });
                    parseMethod.ReturnType = structDeclaration;
                    var valueArg = parseMethod.AddArgument("value", valueType);
                    parseMethod.Statements = new StatementCollection();
                    var result = parseMethod.Statements.Add(new VariableDeclarationStatement("result", structDeclaration));
                    parseMethod.Statements.Add(new ConditionStatement
                    {
                        Condition = new MemberReferenceExpression(structDeclaration, "TryParse").InvokeMethod(valueArg, new MethodInvokeArgumentExpression(result) { Direction = Direction.Out }),
                        TrueStatements = new ReturnStatement(result),
                        FalseStatements = new ThrowStatement(new NewObjectExpression(typeof(FormatException), Expression.Add("Value '", valueArg.Member("ToString").InvokeMethod(), "' is not valid"))),
                    });
                }

                // TryParse
                if (!stronglyTypedStruct.IsTryParseDefined())
                {
                    var parseMethod = structDeclaration.AddMember(new MethodDeclaration("TryParse") { Modifiers = Modifiers.Public | Modifiers.Static });
                    parseMethod.ReturnType = typeof(bool);
                    var valueArg = parseMethod.AddArgument("value", valueType);
                    var resultArg = parseMethod.AddArgument("result", structDeclaration, Direction.Out);
                    if (stronglyTypedStruct.IsReferenceType)
                    {
                        resultArg.Type = resultArg.Type?.MakeNullable();
                    }

                    if (idType == IdType.System_String)
                    {
                        parseMethod.Statements = new StatementCollection()
                        {
                            new AssignStatement(resultArg, new NewObjectExpression(structDeclaration, valueArg)),
                            new ReturnStatement(Expression.True()),
                        };
                    }
                    else
                    {
                        parseMethod.Statements = new StatementCollection();
                        var result = parseMethod.Statements.Add(new VariableDeclarationStatement("id", GetTypeReference(idType)));
                        parseMethod.Statements.Add(new ConditionStatement
                        {
                            Condition = CreateTryParseExpression(),
                            TrueStatements = new StatementCollection
                            {
                                new AssignStatement(resultArg, new NewObjectExpression(structDeclaration, result)),
                                new ReturnStatement(Expression.True()),
                            },
                            FalseStatements = new StatementCollection
                            {
                                new AssignStatement(resultArg, new DefaultValueExpression(structDeclaration)),
                                new ReturnStatement(Expression.False()),
                            },
                        });

                        Expression CreateTryParseExpression()
                        {
                            switch (idType)
                            {
                                case IdType.System_Boolean:
                                    return new MemberReferenceExpression(GetTypeReference(idType), "TryParse").InvokeMethod(
                                        valueArg,
                                        new MethodInvokeArgumentExpression(result) { Direction = Direction.Out });

                                case IdType.System_DateTime:
                                case IdType.System_DateTimeOffset:
                                    return new MemberReferenceExpression(GetTypeReference(idType), "TryParse").InvokeMethod(
                                        valueArg,
                                        new MemberReferenceExpression(typeof(CultureInfo), nameof(CultureInfo.InvariantCulture)),
                                        new MemberReferenceExpression(typeof(DateTimeStyles), nameof(DateTimeStyles.AdjustToUniversal)),
                                        new MethodInvokeArgumentExpression(result) { Direction = Direction.Out });

                                case IdType.System_Guid:
                                    return new MemberReferenceExpression(GetTypeReference(idType), "TryParse").InvokeMethod(
                                        valueArg,
                                        new MethodInvokeArgumentExpression(result) { Direction = Direction.Out });

                                case IdType.System_Decimal:
                                case IdType.System_Double:
                                case IdType.System_Single:
                                case IdType.System_Byte:
                                case IdType.System_SByte:
                                case IdType.System_Int16:
                                case IdType.System_Int32:
                                case IdType.System_Int64:
                                case IdType.System_UInt16:
                                case IdType.System_UInt32:
                                case IdType.System_UInt64:
                                    return new MemberReferenceExpression(GetTypeReference(idType), "TryParse").InvokeMethod(
                                        valueArg,
                                        new MemberReferenceExpression(typeof(NumberStyles), nameof(NumberStyles.Any)),
                                        new MemberReferenceExpression(typeof(CultureInfo), nameof(CultureInfo.InvariantCulture)),
                                        new MethodInvokeArgumentExpression(result) { Direction = Direction.Out });

                                default:
                                    throw new InvalidOperationException("Type not supported");
                            }
                        }
                    }

                }
            }
        }

        private static void GenerateSystemTextJsonConverter(ClassOrStructDeclaration structDeclaration, Compilation compilation, IdType idType)
        {
            var type = compilation.GetTypeByMetadataName("System.Text.Json.Serialization.JsonConverter`1");
            if (type == null)
                return;

            var converter = structDeclaration.AddType(new ClassDeclaration(structDeclaration.Name + "JsonConverter") { Modifiers = Modifiers.Private | Modifiers.Partial });
            structDeclaration.CustomAttributes.Add(new CustomAttribute(new TypeReference("System.Text.Json.Serialization.JsonConverterAttribute")) { Arguments = { new CustomAttributeArgument(new TypeOfExpression(converter)) } });
            converter.BaseType = new TypeReference("System.Text.Json.Serialization.JsonConverter").MakeGeneric(structDeclaration);

            // public abstract void Write (System.Text.Json.Utf8JsonWriter writer, T value, System.Text.Json.JsonSerializerOptions options);
            {
                var writeMethod = converter.AddMember(new MethodDeclaration("Write") { Modifiers = Modifiers.Public | Modifiers.Override });
                var writerArg = writeMethod.AddArgument("writer", new TypeReference("System.Text.Json.Utf8JsonWriter"));
                var valueArg = writeMethod.AddArgument("value", structDeclaration);
                var optionsArg = writeMethod.AddArgument("options", new TypeReference("System.Text.Json.JsonSerializerOptions"));

                if (idType == IdType.System_Boolean)
                {
                    writeMethod.Statements = new StatementCollection
                    {
                        new MethodInvokeExpression(
                            new MemberReferenceExpression(writerArg, "WriteBooleanValue"),
                            new MemberReferenceExpression(valueArg, "Value")),
                    };
                }
                else if (CanUseWriteNumberValue())
                {
                    writeMethod.Statements = new StatementCollection
                    {
                        new MethodInvokeExpression(
                            new MemberReferenceExpression(writerArg, "WriteNumberValue"),
                            new MemberReferenceExpression(valueArg, "Value")),
                    };
                }
                else if (CanUseWriteNumberValueWithCastToInt())
                {
                    writeMethod.Statements = new StatementCollection
                    {
                        new MethodInvokeExpression(
                            new MemberReferenceExpression(writerArg, "WriteNumberValue"),
                            new CastExpression(valueArg.Member("Value"), typeof(int))),
                    };
                }
                else if (CanUseWriteNumberValueWithCastToUInt())
                {
                    writeMethod.Statements = new StatementCollection
                    {
                        new MethodInvokeExpression(
                            new MemberReferenceExpression(writerArg, "WriteNumberValue"),
                            new CastExpression(valueArg.Member("Value"), typeof(uint))),
                    };
                }
                else if (CanUseWriteStringValue())
                {
                    writeMethod.Statements = new StatementCollection
                    {
                        new MethodInvokeExpression(
                            new MemberReferenceExpression(writerArg, "WriteStringValue"),
                            new MemberReferenceExpression(valueArg, "Value")),
                    };
                }
                else
                {
                    // JsonSerializer.Serialize(writer, value.Value, options)
                    writeMethod.Statements = new StatementCollection
                    {
                        new MethodInvokeExpression(
                            new MemberReferenceExpression(new TypeReference("System.Text.Json.JsonSerializer"), "Serialize"),
                            writerArg,
                            new MemberReferenceExpression(valueArg, "Value"),
                            optionsArg),
                    };
                }

                bool CanUseWriteNumberValue()
                {
                    return idType == IdType.System_Decimal
                        || idType == IdType.System_Double
                        || idType == IdType.System_Int32
                        || idType == IdType.System_Int64
                        || idType == IdType.System_Single
                        || idType == IdType.System_UInt32
                        || idType == IdType.System_UInt64;
                }

                bool CanUseWriteNumberValueWithCastToInt()
                {
                    return idType == IdType.System_Int16
                        || idType == IdType.System_SByte;
                }

                bool CanUseWriteNumberValueWithCastToUInt()
                {
                    return idType == IdType.System_Byte
                        || idType == IdType.System_UInt16;
                }

                bool CanUseWriteStringValue()
                {
                    return idType == IdType.System_DateTime
                        || idType == IdType.System_DateTimeOffset
                        || idType == IdType.System_Guid
                        || idType == IdType.System_String;
                }
            }

            // public override T Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
            {
                var readMethod = converter.AddMember(new MethodDeclaration("Read") { Modifiers = Modifiers.Public | Modifiers.Override });
                readMethod.ReturnType = structDeclaration;
                var readerArg = readMethod.AddArgument("reader", new TypeReference("System.Text.Json.Utf8JsonReader"), Direction.InOut);
                _ = readMethod.AddArgument("typeToConvert", typeof(Type));
                _ = readMethod.AddArgument("options", new TypeReference("System.Text.Json.JsonSerializerOptions"));

                readMethod.Statements = new StatementCollection();
                var valueVariable = readMethod.Statements.Add(new VariableDeclarationStatement("value", structDeclaration, new DefaultValueExpression(structDeclaration)));
                readMethod.Statements.Add(new ConditionStatement
                {
                    Condition = CompareTokenType(BinaryOperator.Equals, "StartObject"),
                    TrueStatements = CreateObjectParsing(),
                    FalseStatements = ReadValue(),
                });

                readMethod.Statements.Add(new ReturnStatement(valueVariable));

                BinaryExpression CompareTokenType(BinaryOperator op, string tokenType)
                {
                    return new BinaryExpression(
                        op,
                        readerArg.Member("TokenType"),
                        new MemberReferenceExpression(new TypeReference("System.Text.Json.JsonTokenType"), tokenType));
                }

                StatementCollection CreateObjectParsing()
                {
                    var statements = new StatementCollection();
                    var valueRead = statements.Add(new VariableDeclarationStatement("valueRead", typeof(bool), Expression.False()));
                    statements.Add(ReaderRead());
                    statements.Add(new WhileStatement()
                    {
                        Condition = CompareTokenType(BinaryOperator.NotEquals, "EndObject"),
                        Body = new StatementCollection
                        {
                            new ConditionStatement()
                            {
                                Condition = Expression.And(
                                    UnaryExpression.Not(valueRead),
                                    CompareTokenType(BinaryOperator.Equals, "PropertyName"),
                                    readerArg.Member("ValueTextEquals").InvokeMethod(new LiteralExpression("Value"))),
                                TrueStatements = new StatementCollection
                                {
                                    ReaderRead(),
                                    ReadValue(),
                                    new AssignStatement(valueRead, Expression.True()),
                                    ReaderRead(),
                                },
                                FalseStatements = new StatementCollection
                                {
                                    ReaderSkip(),
                                    ReaderRead(),
                                },
                            },
                        },
                    });
                    return statements;
                }

                Statement ReaderRead()
                {
                    return new MethodInvokeExpression(readerArg.Member("Read"));
                }

                Statement ReaderSkip()
                {
                    return new MethodInvokeExpression(readerArg.Member("Skip"));
                }

                Statement ReadValue()
                {
                    return
                        new AssignStatement(
                            valueVariable,
                            new NewObjectExpression(
                                structDeclaration,
                                new MethodInvokeExpression(new MemberReferenceExpression(readerArg, "Get" + GetShortName(GetTypeReference(idType))))))
                        {
                            NullableContext = CodeDom.NullableContext.Disable,
                        };
                }
            }
        }

        private static void GenerateNewtonsoftJsonConverter(ClassOrStructDeclaration structDeclaration, Compilation compilation, IdType idType)
        {
            var type = compilation.GetTypeByMetadataName("Newtonsoft.Json.JsonConverter");
            if (type == null)
                return;

            var converter = structDeclaration.AddType(new ClassDeclaration(structDeclaration.Name + "NewtonsoftJsonConverter") { Modifiers = Modifiers.Private | Modifiers.Partial });
            structDeclaration.CustomAttributes.Add(new CustomAttribute(new TypeReference("Newtonsoft.Json.JsonConverterAttribute")) { Arguments = { new CustomAttributeArgument(new TypeOfExpression(converter)) } });
            converter.BaseType = new TypeReference("Newtonsoft.Json.JsonConverter");

            // bool CanRead => true
            {
                var canRead = converter.AddMember(new PropertyDeclaration("CanRead", typeof(bool)) { Modifiers = Modifiers.Public | Modifiers.Override });
                canRead.Getter = new PropertyAccessorDeclaration()
                {
                    Statements = new ReturnStatement(Expression.True()),
                };
            }

            // bool CanWrite => true
            {
                var canWrite = converter.AddMember(new PropertyDeclaration("CanWrite", typeof(bool)) { Modifiers = Modifiers.Public | Modifiers.Override });
                canWrite.Getter = new PropertyAccessorDeclaration()
                {
                    Statements = new ReturnStatement(Expression.True()),
                };
            }

            // CanConvert
            {
                var method = converter.AddMember(new MethodDeclaration("CanConvert") { Modifiers = Modifiers.Public | Modifiers.Override });
                method.ReturnType = typeof(bool);
                var typeArg = method.AddArgument("type", typeof(Type));

                method.Statements = new ReturnStatement(new BinaryExpression(BinaryOperator.Equals, typeArg, new TypeOfExpression(structDeclaration)));
            }

            // public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
            {
                var method = converter.AddMember(new MethodDeclaration("WriteJson") { Modifiers = Modifiers.Public | Modifiers.Override });
                var writerArg = method.AddArgument("writer", new TypeReference("Newtonsoft.Json.JsonWriter"));
                var valueArg = method.AddArgument("value", new TypeReference(typeof(object)).MakeNullable());
                _ = method.AddArgument("serializer", new TypeReference("Newtonsoft.Json.JsonSerializer"));

                method.Statements = new ConditionStatement
                {
                    Condition = Expression.EqualsNull(valueArg),
                    TrueStatements = writerArg.Member("WriteNull").InvokeMethod(),
                    FalseStatements = writerArg.Member("WriteValue").InvokeMethod(new CastExpression(valueArg, structDeclaration).Member("Value")),
                };
            }

            // public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
            {
                var method = converter.AddMember(new MethodDeclaration("ReadJson") { Modifiers = Modifiers.Public | Modifiers.Override });
                method.ReturnType = typeof(object);
                var readerArg = method.AddArgument("reader", new TypeReference("Newtonsoft.Json.JsonReader"));
                _ = method.AddArgument("objectType", typeof(Type));
                _ = method.AddArgument("existingValue", new TypeReference(typeof(object)).MakeNullable());
                var serializerArg = method.AddArgument("serializer", new TypeReference("Newtonsoft.Json.JsonSerializer"));

                method.Statements = new StatementCollection();

                var valueVariable = method.Statements.Add(new VariableDeclarationStatement("value", structDeclaration, new DefaultValueExpression(structDeclaration)));
                method.Statements.Add(new ConditionStatement
                {
                    Condition = CompareTokenType(BinaryOperator.Equals, "StartObject"),
                    TrueStatements = CreateObjectParsing(),
                    FalseStatements = ReadValue(),
                });

                method.Statements.Add(new ReturnStatement(valueVariable));

                BinaryExpression CompareTokenType(BinaryOperator op, string tokenType)
                {
                    return new BinaryExpression(
                        op,
                        readerArg.Member("TokenType"),
                        new MemberReferenceExpression(new TypeReference("Newtonsoft.Json.JsonToken"), tokenType));
                }

                StatementCollection CreateObjectParsing()
                {
                    var statements = new StatementCollection();
                    var valueRead = statements.Add(new VariableDeclarationStatement("valueRead", typeof(bool), Expression.False()));
                    statements.Add(ReaderRead());
                    statements.Add(new WhileStatement()
                    {
                        Condition = CompareTokenType(BinaryOperator.NotEquals, "EndObject"),
                        Body = new StatementCollection
                        {
                            new ConditionStatement()
                            {
                                Condition = Expression.And(
                                    UnaryExpression.Not(valueRead),
                                    CompareTokenType(BinaryOperator.Equals, "PropertyName"),
                                    new BinaryExpression(BinaryOperator.Equals, new CastExpression(readerArg.Member("Value"), new TypeReference(typeof(string)).MakeNullable()), new LiteralExpression("Value"))),
                                TrueStatements = new StatementCollection
                                {
                                    ReaderRead(),
                                    ReadValue(),
                                    new AssignStatement(valueRead, Expression.True()),
                                    ReaderRead(),
                                },
                                FalseStatements = new StatementCollection
                                {
                                    ReaderSkip(),
                                    ReaderRead(),
                                },
                            },
                        },
                    });
                    return statements;
                }

                Statement ReaderRead()
                {
                    return new MethodInvokeExpression(readerArg.Member("Read"));
                }

                Statement ReaderSkip()
                {
                    return new MethodInvokeExpression(readerArg.Member("Skip"));
                }

                Statement ReadValue()
                {
                    return
                        new AssignStatement(
                            valueVariable,
                            new NewObjectExpression(
                                structDeclaration,
                                serializerArg.Member("Deserialize").InvokeMethod(new[] { GetTypeReference(idType) }, readerArg)))
                        {
                            NullableContext = CodeDom.NullableContext.Disable,
                        };
                }
            }
        }

        private static void GenerateTypeConverter(ClassOrStructDeclaration typeDeclaration, Compilation compilation, IdType idType)
        {
            var type = compilation.GetTypeByMetadataName("System.ComponentModel.TypeConverter");
            if (type == null)
                return;

            var converter = typeDeclaration.AddType(new ClassDeclaration(typeDeclaration.Name + "TypeConverter") { Modifiers = Modifiers.Private | Modifiers.Partial });
            typeDeclaration.CustomAttributes.Add(new CustomAttribute(new TypeReference("System.ComponentModel.TypeConverterAttribute")) { Arguments = { new CustomAttributeArgument(new TypeOfExpression(converter)) } });
            converter.BaseType = new TypeReference("System.ComponentModel.TypeConverter");

            // public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
            {
                var method = converter.AddMember(new MethodDeclaration("CanConvertFrom") { Modifiers = Modifiers.Public | Modifiers.Override });
                method.ReturnType = typeof(bool);
                _ = method.AddArgument("context", new TypeReference("System.ComponentModel.ITypeDescriptorContext"));
                var typeArg = method.AddArgument("sourceType", typeof(Type));

                method.Statements = new ReturnStatement(
                    Expression.Or(
                        new BinaryExpression(BinaryOperator.Equals, typeArg, new TypeOfExpression(typeof(string))),
                        new BinaryExpression(BinaryOperator.Equals, typeArg, new TypeOfExpression(GetTypeReference(idType))),
                        new BinaryExpression(BinaryOperator.Equals, typeArg, new TypeOfExpression(typeDeclaration))));
            }

            // public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
            {
                var method = converter.AddMember(new MethodDeclaration("ConvertFrom") { Modifiers = Modifiers.Public | Modifiers.Override });
                method.ReturnType = new TypeReference(typeof(object)).MakeNullable();
                _ = method.AddArgument("context", new TypeReference("System.ComponentModel.ITypeDescriptorContext"));
                _ = method.AddArgument("culture", new TypeReference(typeof(CultureInfo)));
                var valueArg = method.AddArgument("value", typeof(object));
                method.Statements = new StatementCollection
                {
                    new ConditionStatement
                    {
                        Condition = Expression.EqualsNull(valueArg),
                        TrueStatements = new ReturnStatement(new DefaultValueExpression(GetTypeReference(idType))),
                        FalseStatements = new ConditionStatement
                        {
                            Condition = new IsInstanceOfTypeExpression(valueArg, GetTypeReference(idType)),
                            TrueStatements = new ReturnStatement(new MemberReferenceExpression(typeDeclaration, "From" + GetShortName(GetTypeReference(idType))).InvokeMethod(new CastExpression(valueArg, GetTypeReference(idType)))),
                            FalseStatements = new ConditionStatement
                            {
                                Condition = new IsInstanceOfTypeExpression(valueArg, typeof(string)),
                                TrueStatements = new ReturnStatement(new MemberReferenceExpression(typeDeclaration, "Parse").InvokeMethod(new CastExpression(valueArg, typeof(string)))),
                                FalseStatements = new ThrowStatement(new NewObjectExpression(typeof(ArgumentException), Expression.Add("Cannot convert '", valueArg, "' to " + typeDeclaration.Name))),
                            },
                        },
                    },
                };
            }

            // public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
            {
                var method = converter.AddMember(new MethodDeclaration("CanConvertTo") { Modifiers = Modifiers.Public | Modifiers.Override });
                method.ReturnType = typeof(bool);
                _ = method.AddArgument("context", new TypeReference("System.ComponentModel.ITypeDescriptorContext"));
                var typeArg = method.AddArgument("destinationType", typeof(Type));
                method.Statements = new ReturnStatement(
                    Expression.Or(
                        new BinaryExpression(BinaryOperator.Equals, typeArg, new TypeOfExpression(GetTypeReference(idType))),
                        new BinaryExpression(BinaryOperator.Equals, typeArg, new TypeOfExpression(typeDeclaration)),
                        new BinaryExpression(BinaryOperator.Equals, typeArg, new TypeOfExpression(typeof(string)))));
            }

            // public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
            {
                var method = converter.AddMember(new MethodDeclaration("ConvertTo") { Modifiers = Modifiers.Public | Modifiers.Override });
                method.ReturnType = typeof(object);
                _ = method.AddArgument("context", new TypeReference("System.ComponentModel.ITypeDescriptorContext"));
                _ = method.AddArgument("culture", new TypeReference(typeof(CultureInfo)));
                var valueArg = method.AddArgument("value", typeof(object));
                var destinationTypeArg = method.AddArgument("destinationType", typeof(Type));
                method.Statements = new StatementCollection()
                {
                    new ConditionStatement
                    {
                        Condition = new BinaryExpression(BinaryOperator.Equals, destinationTypeArg, new TypeOfExpression(typeof(string))),
                        TrueStatements = new ReturnStatement(new CastExpression(valueArg, typeDeclaration).Member("ValueAsString")),
                    },
                    new ConditionStatement
                    {
                        Condition = new BinaryExpression(BinaryOperator.Equals, destinationTypeArg, new TypeOfExpression(typeDeclaration)),
                        TrueStatements = new ReturnStatement(valueArg),
                    },
                    new ConditionStatement
                    {
                        Condition = new BinaryExpression(BinaryOperator.Equals, destinationTypeArg, new TypeOfExpression(GetTypeReference(idType))),
                        TrueStatements = new ReturnStatement(new CastExpression(valueArg, typeDeclaration).Member("Value")),
                    },
                    new ThrowStatement(new NewObjectExpression(typeof(ArgumentException), Expression.Add("Cannot convert '", valueArg, "' to '", destinationTypeArg, "'"))),
                };
            }
        }

        private record StronglyTypedType(ISymbol ContainingSymbol, ITypeSymbol? ExistingTypeSymbol, string Name, AttributeInfo AttributeInfo, TypeDeclarationSyntax TypeDeclarationSyntax)
        {
            public bool IsClass => TypeDeclarationSyntax.IsKind(SyntaxKind.ClassDeclaration);

            public bool IsRecord => TypeDeclarationSyntax.IsKind(SyntaxKind.RecordDeclaration);

            public bool IsStruct => TypeDeclarationSyntax.IsKind(SyntaxKind.StructDeclaration);

            public bool IsReferenceType => IsClass || IsRecord;

            public bool IsCtorDefined()
            {
                return ExistingTypeSymbol != null && ExistingTypeSymbol.GetMembers(".ctor").OfType<IMethodSymbol>()
                    .Any(m => !m.IsStatic && m.Parameters.Length == 1 && SymbolEqualityComparer.Default.Equals(m.Parameters[0].Type, AttributeInfo.IdTypeSymbol));
            }

            public bool IsFieldDefined()
            {
                return ExistingTypeSymbol != null && ExistingTypeSymbol.GetMembers(FieldName).Any();
            }

            public bool IsValueDefined()
            {
                return ExistingTypeSymbol != null && ExistingTypeSymbol.GetMembers(PropertyName).Any();
            }

            public bool IsValueAsStringDefined()
            {
                return ExistingTypeSymbol != null && ExistingTypeSymbol.GetMembers(PropertyAsStringName).Any();
            }

            public bool IsToStringDefined()
            {
                return ExistingTypeSymbol != null && ExistingTypeSymbol.GetMembers(nameof(ToString)).OfType<IMethodSymbol>()
                    .Any(m => !m.IsStatic && m.Parameters.Length == 0 && m.ReturnType?.SpecialType == SpecialType.System_String);
            }

            public bool IsGetHashcodeDefined()
            {
                return ExistingTypeSymbol != null && ExistingTypeSymbol.GetMembers(nameof(GetHashCode)).OfType<IMethodSymbol>()
                    .Any(m => !m.IsStatic && m.Parameters.Length == 0 && m.ReturnType?.SpecialType == SpecialType.System_Int32);
            }

            public bool IsEqualsDefined()
            {
                return ExistingTypeSymbol != null && ExistingTypeSymbol.GetMembers(nameof(Equals)).OfType<IMethodSymbol>()
                    .Any(m => !m.IsStatic && m.Parameters.Length == 1 && m.Parameters[0].Type.SpecialType == SpecialType.System_Object && m.ReturnType?.SpecialType == SpecialType.System_Boolean);
            }

            public bool IsIEquatableEqualsDefined()
            {
                return ExistingTypeSymbol != null && ExistingTypeSymbol.GetMembers(nameof(Equals)).OfType<IMethodSymbol>()
                    .Any(m => !m.IsStatic && m.Parameters.Length == 1 && SymbolEqualityComparer.Default.Equals(ExistingTypeSymbol, m.Parameters[0].Type) && m.ReturnType?.SpecialType == SpecialType.System_Boolean);
            }

            public bool IsOpEqualsDefined()
            {
                return ExistingTypeSymbol != null && ExistingTypeSymbol.GetMembers("op_Equality").OfType<IMethodSymbol>()
                    .Any(m => m.IsStatic && m.Parameters.Length == 2 && SymbolEqualityComparer.Default.Equals(ExistingTypeSymbol, m.Parameters[0].Type) && SymbolEqualityComparer.Default.Equals(ExistingTypeSymbol, m.Parameters[1].Type) && m.ReturnType?.SpecialType == SpecialType.System_Boolean);
            }

            public bool IsOpNotEqualsDefined()
            {
                return ExistingTypeSymbol != null && ExistingTypeSymbol.GetMembers("op_Inequality").OfType<IMethodSymbol>()
                    .Any(m => m.IsStatic && m.Parameters.Length == 2 && SymbolEqualityComparer.Default.Equals(ExistingTypeSymbol, m.Parameters[0].Type) && SymbolEqualityComparer.Default.Equals(ExistingTypeSymbol, m.Parameters[1].Type) && m.ReturnType?.SpecialType == SpecialType.System_Boolean);
            }

            public bool IsTryParseDefined()
            {
                return ExistingTypeSymbol != null && ExistingTypeSymbol.GetMembers("TryParse").OfType<IMethodSymbol>()
                    .Any(m => m.IsStatic);
            }

            public bool IsParseDefined()
            {
                return ExistingTypeSymbol != null && ExistingTypeSymbol.GetMembers("Parse").OfType<IMethodSymbol>()
                    .Any(m => m.IsStatic);
            }
        }

        private record AttributeInfo(AttributeSyntax AttributeSyntax, IdType IdType, ITypeSymbol IdTypeSymbol);

        private sealed class Receiver : ISyntaxReceiver
        {
            public List<TypeDeclarationSyntax> Types { get; } = new();

            public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
            {
                if (syntaxNode.IsKind(SyntaxKind.StructDeclaration))
                {
                    Types.Add((TypeDeclarationSyntax)syntaxNode);
                }
                else if (syntaxNode.IsKind(SyntaxKind.ClassDeclaration))
                {
                    Types.Add((TypeDeclarationSyntax)syntaxNode);
                }
                else if (syntaxNode.IsKind(SyntaxKind.RecordDeclaration))
                {
                    Types.Add((TypeDeclarationSyntax)syntaxNode);
                }
            }
        }

        private enum IdType
        {
            System_Boolean,
            System_Byte,
            System_DateTime,
            System_DateTimeOffset,
            System_Decimal,
            System_Double,
            System_Guid,
            System_Int16,
            System_Int32,
            System_Int64,
            System_SByte,
            System_Single,
            System_String,
            System_UInt16,
            System_UInt32,
            System_UInt64,
        }
    }
}
