<#@ template debug="true" hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Linq" #>
<#@ import namespace="System.Linq" #>
<# var count = 7; #>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     GitVersion
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

#pragma warning disable MA0042 // Do not use blocking call
#nullable enable

using System.Runtime.CompilerServices;

namespace Meziantou.Framework.Threading.Tasks;

// https://www.meziantou.net/get-the-result-of-multiple-tasks-in-a-valuetuple-and-whenall.htm
public static partial class TaskExtensions
{
    public static TaskAwaiter<T1> GetAwaiter<T1>(this ValueTuple<Task<T1>> tasks) => tasks.Item1.GetAwaiter();
<# for (int i = 2; i <= count; i++) { #>
    public static TupleTaskAwaiter<<#= GetTemplateString(i) #>> GetAwaiter<<#= GetTemplateString(i) #>>(this ValueTuple<<#= Join(", ", i, i => "Task<T" + i + ">") #>> tasks) => new(tasks);
<# } #>
    public static ConfiguredTaskAwaitable<T1> ConfigureAwait<T1>(this ValueTuple<Task<T1>> tasks, bool continueOnCapturedContext) => tasks.Item1.ConfigureAwait(continueOnCapturedContext);
    public static ConfiguredTaskAwaitable<T1> ConfigureAwait<T1>(this ValueTuple<Task<T1>> tasks, ConfigureAwaitOptions options) => tasks.Item1.ConfigureAwait(options);
<# for (int i = 2; i <= count; i++) { #>
    public static TupleConfiguredTaskAwaitable<<#= GetTemplateString(i) #>> ConfigureAwait<<#= GetTemplateString(i) #>>(this ValueTuple<<#= Join(", ", i, i => "Task<T" + i + ">") #>> tasks, bool continueOnCapturedContext) => new(tasks, continueOnCapturedContext ? ConfigureAwaitOptions.ContinueOnCapturedContext : ConfigureAwaitOptions.None);
    public static TupleConfiguredTaskAwaitable<<#= GetTemplateString(i) #>> ConfigureAwait<<#= GetTemplateString(i) #>>(this ValueTuple<<#= Join(", ", i, i => "Task<T" + i + ">") #>> tasks, ConfigureAwaitOptions options) => new(tasks, options);
<# } #>
    public static TaskAwaiter GetAwaiter(this ValueTuple<Task> tasks) => tasks.Item1.GetAwaiter();
    public static ConfiguredTaskAwaitable ConfigureAwait(this ValueTuple<Task> tasks, bool continueOnCapturedContext) => tasks.Item1.ConfigureAwait(continueOnCapturedContext);
    public static ConfiguredTaskAwaitable ConfigureAwait(this ValueTuple<Task> tasks, ConfigureAwaitOptions options) => tasks.Item1.ConfigureAwait(options);
<# for (int i = 2; i <= count; i++) { #>
    public static TaskAwaiter GetAwaiter(this ValueTuple<<#= Join(", ", i, i => "Task") #>> tasks) => Task.WhenAll(<#= Join(", ", i, i => "tasks.Item" + i) #>).GetAwaiter();
    public static TupleConfiguredTaskAwaitable<#= i #> ConfigureAwait(this ValueTuple<<#= Join(", ", i, i => "Task") #>> tasks, bool continueOnCapturedContext) => new(tasks, continueOnCapturedContext ? ConfigureAwaitOptions.ContinueOnCapturedContext : ConfigureAwaitOptions.None);
    public static TupleConfiguredTaskAwaitable<#= i #> ConfigureAwait(this ValueTuple<<#= Join(", ", i, i => "Task") #>> tasks, ConfigureAwaitOptions options) => new(tasks, options);
<# } #>
<# for (int i = 1; i <= count; i++) { #>
    public static async ValueTask<ValueTuple<<#= GetTemplateString(i) #>>> WhenAll<<#= GetTemplateString(i) #>>(<#= Join(", ", i, i => "ValueTask<T" + i + "> task" + i) #>)
    {
        List<Exception>? observedExceptions = null;
        <# for (int j = 1; j <= i; j++) { #>T<#=j#> result<#=j#>;
        try
        {
            result<#=j#> = await task<#=j#>.ConfigureAwait(false);
        }
        catch (Exception ex)
        {
            observedExceptions ??= [];
            observedExceptions.Add(ex);
            Unsafe.SkipInit(out result<#=j#>);
        }
        <# } #>

        if (observedExceptions is not null)
        {
            throw new AggregateException(observedExceptions);
        }

        return new(<#= Join(", ", i, i => "result" + i) #>);
    }

    public static ValueTaskAwaiter<ValueTuple<<#= GetTemplateString(i) #>>> GetAwaiter<<#= GetTemplateString(i) #>>(this ValueTuple<<#= Join(", ", i, i => "ValueTask<T" + i + ">") #>> tasks) => WhenAll(<#= Join(", ", i, i => "tasks.Item" + i) #>).GetAwaiter();
<# } #>
    private static ValueTask WhenAll(ValueTask task1) => task1;
<# for (int i = 2; i <= count; i++) { #>
    private static async ValueTask WhenAll(<#= Join(", ", i, i => "ValueTask task" + i) #>)
    {
        List<Exception>? observedExceptions = null;
        <# for (int j = 1; j <= i; j++) { #>try
        {
            await task<#=j#>.ConfigureAwait(false);
        }
        catch (Exception ex)
        {
            observedExceptions ??= [];
            observedExceptions.Add(ex);
        }
        <# } #>

        if (observedExceptions is not null)
        {
            throw new AggregateException(observedExceptions);
        }
    }

    public static ValueTaskAwaiter GetAwaiter(this ValueTuple<<#= Join(", ", i, i => "ValueTask") #>> tasks) => WhenAll(<#= Join(", ", i, i => "tasks.Item" + i) #>).GetAwaiter();
<# } #>

<# for (int i = 2; i <= count; i++) { #>
    public readonly struct TupleTaskAwaiter<<#= GetTemplateString(i) #>>(ValueTuple<<#= Join(", ", i, i => "Task<T" + i + ">") #>> tasks) : ICriticalNotifyCompletion
    {
        private readonly TaskAwaiter _whenAllAwaiter = Task.WhenAll(<#= Join(", ", i, i => "tasks.Item" + i) #>).GetAwaiter();

        public bool IsCompleted => _whenAllAwaiter.IsCompleted;
        public void OnCompleted(Action continuation) => _whenAllAwaiter.OnCompleted(continuation);
        public void UnsafeOnCompleted(Action continuation) => _whenAllAwaiter.UnsafeOnCompleted(continuation);

        public ValueTuple<<#= GetTemplateString(i) #>> GetResult()
        {
            _whenAllAwaiter.GetResult();
            return new(<#= Join(", ", i, i => "tasks.Item" + i + ".Result") #>);
        }
    }

    public readonly struct TupleConfiguredTaskAwaitable<<#= GetTemplateString(i) #>>(ValueTuple<<#= Join(", ", i, i => "Task<T" + i + ">") #>> tasks, ConfigureAwaitOptions options)
    {
        public Awaiter GetAwaiter() => new(tasks, options);

        public readonly struct Awaiter(ValueTuple<<#= Join(", ", i, i => "Task<T" + i + ">") #>> tasks, ConfigureAwaitOptions options) : ICriticalNotifyCompletion
        {
            private readonly ConfiguredTaskAwaitable.ConfiguredTaskAwaiter _whenAllAwaiter = Task.WhenAll(<#= Join(", ", i, i => "tasks.Item" + i) #>).ConfigureAwait(options).GetAwaiter();

            public bool IsCompleted => _whenAllAwaiter.IsCompleted;
            public void OnCompleted(Action continuation) => _whenAllAwaiter.OnCompleted(continuation);
            public void UnsafeOnCompleted(Action continuation) => _whenAllAwaiter.UnsafeOnCompleted(continuation);

            public ValueTuple<<#= Join(", ", i, i => "T" + i) #>> GetResult()
            {
                _whenAllAwaiter.GetResult();
                return new(<#= Join(", ", i, i => "tasks.Item" + i + ".Result") #>);
            }
        }
    }

    public readonly struct TupleTaskAwaiter<#= i #>(ValueTuple<<#= Join(", ", i, i => "Task") #>> tasks) : ICriticalNotifyCompletion
    {
        private readonly TaskAwaiter _whenAllAwaiter = Task.WhenAll(<#= Join(", ", i, i => "tasks.Item" + i) #>).GetAwaiter();

        public bool IsCompleted => _whenAllAwaiter.IsCompleted;
        public void OnCompleted(Action continuation) => _whenAllAwaiter.OnCompleted(continuation);
        public void UnsafeOnCompleted(Action continuation) => _whenAllAwaiter.UnsafeOnCompleted(continuation);
        public void GetResult() => _whenAllAwaiter.GetResult();
    }

    public readonly struct TupleConfiguredTaskAwaitable<#= i #>(ValueTuple<<#= Join(", ", i, i => "Task") #>> tasks, ConfigureAwaitOptions options)
    {
        private readonly ValueTuple<<#= Join(", ", i, i => "Task") #>> _tasks = tasks;
        private readonly ConfigureAwaitOptions _options = options;

        public Awaiter GetAwaiter() => new(_tasks, _options);

        public readonly struct Awaiter(ValueTuple<<#= Join(", ", i, i => "Task") #>> tasks, ConfigureAwaitOptions options) : ICriticalNotifyCompletion
        {
            private readonly ConfiguredTaskAwaitable.ConfiguredTaskAwaiter _whenAllAwaiter = Task.WhenAll(<#= Join(", ", i, i => "tasks.Item" + i) #>).ConfigureAwait(options).GetAwaiter();

            public bool IsCompleted => _whenAllAwaiter.IsCompleted;
            public void OnCompleted(Action continuation) => _whenAllAwaiter.OnCompleted(continuation);
            public void UnsafeOnCompleted(Action continuation) => _whenAllAwaiter.UnsafeOnCompleted(continuation);
            public void GetResult() => _whenAllAwaiter.GetResult();
        }
    }
<# } #>
}
<#+
    string GetTemplateString(int count)
    {
        return Join(", ", count, i => "T" + i);
    }

    string Join(string separator, int count, Func<int, string> selector)
    {
        var str = "";
        for (var i = 1; i <= count; i++)
        {
            if (i > 1)
            {
                str += separator;
            }

            str += selector(i);
        }
        return str;
    }
#>
