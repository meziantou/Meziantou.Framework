<#@ template debug="true" hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Linq" #>
<#@ import namespace="System.Linq" #>
<# var count = 7; #>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     GitVersion
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

#pragma warning disable MA0042 // Do not use blocking call
#nullable enable

using System.Runtime.CompilerServices;

namespace Meziantou.Framework;

// https://www.meziantou.net/get-the-result-of-multiple-tasks-in-a-valuetuple-and-whenall.htm
public static partial class TaskEx
{
<# for (int i = 2; i <= count; i++) { #>
    public static async Task<(<#= GetTemplateString(i) #>)> WhenAll<<#= GetTemplateString(i) #>>(<#= Join(", ", i, i => "Task<T" + i + "> task" + i) #>)
    {
        <# for (int j = 1; j <= i; j++) { #>
        ArgumentNullException.ThrowIfNull(task<#= j #>);
        <# } #>
        await Task.WhenAll(<#= Join(", ", i, i => "task" + i) #>).ConfigureAwait(false);
        return (<#= Join(", ", i, i => "task" + i + ".Result") #>);
    }

    public static TaskAwaiter<(<#= GetTemplateString(i) #>)> GetAwaiter<<#= GetTemplateString(i) #>>(this (<#= Join(", ", i, i => "Task<T" + i + ">") #>) tasks)
    {
        return WhenAll(<#= Join(", ", i, i => "tasks.Item" + i) #>).GetAwaiter();
    }
<# } #>

<# for (int i = 2; i <= count; i++) { #>
    public static TaskAwaiter GetAwaiter(this (<#= Join(", ", i, i => "Task") #>) tasks)
    {
        return Task.WhenAll(<#= Join(", ", i, i => "tasks.Item" + i) #>).GetAwaiter();
    }
<# } #>

<# for (int i = 2; i <= count; i++) { #>
    public static async ValueTask<(<#= GetTemplateString(i) #>)> WhenAll<<#= GetTemplateString(i) #>>(<#= Join(", ", i, i => "ValueTask<T" + i + "> task" + i) #>)
    {
        List<Exception>? observedExceptions = null;
        <# for (int j = 1; j <= i; j++) { #>
        T<#=j#> result<#=j#>;        
        try
        {
            result<#=j#> = await task<#=j#>.ConfigureAwait(false);
        }
        catch (Exception ex)
        {
            observedExceptions ??= new();
            observedExceptions.Add(ex);
            Unsafe.SkipInit(out result<#=j#>);
        }
        <# } #>

        if (observedExceptions is not null)
        {
            throw new AggregateException(observedExceptions);
        }

        return (<#= Join(", ", i, i => "result" + i) #>);
    }

    public static ValueTaskAwaiter<(<#= GetTemplateString(i) #>)> GetAwaiter<<#= GetTemplateString(i) #>>(this (<#= Join(", ", i, i => "ValueTask<T" + i + ">") #>) tasks)
    {
        return WhenAll(<#= Join(", ", i, i => "tasks.Item" + i) #>).GetAwaiter();
    }
<# } #>

<# for (int i = 2; i <= count; i++) { #>
    public static async ValueTask WhenAll(<#= Join(", ", i, i => "ValueTask task" + i) #>)
    {
        List<Exception>? observedExceptions = null;
        <# for (int j = 1; j <= i; j++) { #>
        try
        {
            await task<#=j#>.ConfigureAwait(false);
        }
        catch (Exception ex)
        {
            observedExceptions ??= new();
            observedExceptions.Add(ex);
        }
        <# } #>

        if (observedExceptions is not null)
        {
            throw new AggregateException(observedExceptions);
        }
    }

    public static ValueTaskAwaiter GetAwaiter(this (<#= Join(", ", i, i => "ValueTask") #>) tasks)
    {
        return WhenAll(<#= Join(", ", i, i => "tasks.Item" + i) #>).GetAwaiter();
    }
<# } #>
}
<#+
    string GetTemplateString(int count)
    {
        return Join(", ", count, i => "T" + i);
    }
    
    string Join(string separator, int count, Func<int, string> selector)
    {
        var str = "";
        for (var i = 1; i <= count; i++)
        {
            if (i > 1)
            {
                str += separator;
            }

            str += selector(i);
        }
        return str;
    }
#>
