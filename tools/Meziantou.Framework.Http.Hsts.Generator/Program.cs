#pragma warning disable CA1812 // Avoid uninstantiated internal classes
#pragma warning disable MA0004 // Use Task.ConfigureAwait
#pragma warning disable MA0047 // Declare types in namespaces
#pragma warning disable MA0048 // File name must match type name
#pragma warning disable CA1849 // Call async methods when in an async method
#pragma warning disable MA0042 // Do not use blocking calls in an async method
using System.Diagnostics;
using System.IO.Compression;
using System.Net.Http.Headers;
using System.Net.Http.Json;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Xml;
using System.Xml.Linq;
using Meziantou.Framework;
using Meziantou.Framework.Versioning;

if (!FullPath.CurrentDirectory().TryFindFirstAncestorOrSelf(path => Directory.Exists(path / ".git"), out var root))
    throw new InvalidOperationException("Cannot find git root from " + FullPath.CurrentDirectory());

var outputPath = root / "src" / "Meziantou.Framework.Http.Hsts";
var outputFilePath = outputPath / "HstsDomainPolicyCollection.g.cs";
var csprojPath = root / "src" / "Meziantou.Framework.Http.Hsts" / "Meziantou.Framework.Http.Hsts.csproj";

var (entries, fileUrl, commitSha, commitDate) = await LoadEntries();

// Start generating the code
var entriesThreshold = 10;
var maxSegments = entries.Max(e => e.SegmentCount);

var sb = new StringBuilder();
sb.Append($"        CollectionsMarshal.SetCount(_policies, {maxSegments.ToString(CultureInfo.InvariantCulture)});\n\n");
for (var i = 1; i <= maxSegments; i++)
{
    var count = entries.Count(e => e.SegmentCount == i);
    sb.Append($"        var dict{i.ToString(CultureInfo.InvariantCulture)} = new ConcurrentDictionary<string, HstsDomainPolicy>(concurrencyLevel: -1, capacity: {(count + 10).ToString(CultureInfo.InvariantCulture)}, comparer: StringComparer.OrdinalIgnoreCase);\n");
    sb.Append($"        _policies[{(i - 1).ToString(CultureInfo.InvariantCulture)}] = dict{i.ToString(CultureInfo.InvariantCulture)};\n");

    if (count < entriesThreshold)
    {
        foreach (var entry in entries.Where(e => e.SegmentCount == i).OrderBy(e => e.Name, StringComparer.Ordinal))
        {
            var expiresIn = entry.Policy switch
            {
                "bulk-18-weeks" => "_expires18weeks",
                "bulk-1-year" => "_expires1year",
                _ => "_expires1year",
            };
            sb.Append($"        dict{i.ToString(CultureInfo.InvariantCulture)}.TryAdd(\"{entry.Name}\", new HstsDomainPolicy(\"{entry.Name}\", {expiresIn}, {entry.IncludeSubdomains.ToString(CultureInfo.InvariantCulture).ToLowerInvariant()}));\n");
        }
    }
    else
    {
        sb.Append($"        Load(dict{i.ToString(CultureInfo.InvariantCulture)}, {count.ToString(CultureInfo.InvariantCulture)}, \"{$"preload_{i}.bin"}\");\n");
    }
    sb.Append('\n');
}

void AddPreloadData()
{
    foreach (var entryGroup in entries.GroupBy(e => e.SegmentCount).OrderBy(group => group.Key))
    {
        if (entryGroup.Count() < entriesThreshold)
            continue;

        using var ms = new MemoryStream();
        using (var gz = new GZipStream(ms, CompressionLevel.SmallestSize))
        using (var writer = new BinaryWriter(gz))
        {
            foreach (var entry in entryGroup.OrderBy(entry => entry.Name, StringComparer.Ordinal))
            {
                var expiresIn = entry.Policy switch
                {
                    "bulk-18-weeks" => 18 * 7 * 24 * 60 * 60,
                    "bulk-1-year" => 365 * 24 * 60 * 60,
                    _ => 365 * 24 * 60 * 60,
                };

                writer.Write(entry.Name);
                writer.Write(entry.IncludeSubdomains);
                writer.Write(expiresIn);
            }
        }

        var array = ms.ToArray();
        File.WriteAllBytes(outputPath / $"preload_{entryGroup.Key}.bin", array);
    }
}

Directory.GetFiles(outputPath, "preload_*.bin").ToList().ForEach(File.Delete);
AddPreloadData();

var result = $$"""
    // <auto-generated />
    #nullable enable

    using System.Collections.Concurrent;
    using System.Runtime.InteropServices;

    namespace Meziantou.Framework.Http;

    partial class HstsDomainPolicyCollection
    {
        private void LoadPreloadDomains()
        {
            // HSTS preload data source: {{fileUrl}}
            // Commit date: {{commitDate.ToString("O", CultureInfo.InvariantCulture)}}
    {{sb.ToString().TrimEnd('\n')}}
        }
    }
    """.ReplaceLineEndings("\n");

// Write file and update csproj
if (!File.Exists(outputFilePath) || File.ReadAllText(outputFilePath).ReplaceLineEndings("\n") != result)
{
    var encoding = new UTF8Encoding(encoderShouldEmitUTF8Identifier: false);
    File.WriteAllText(outputFilePath, result, encoding);
    Console.WriteLine("The file has been updated");

    var doc = XDocument.Load(csprojPath, LoadOptions.PreserveWhitespace);
    var versionNode = doc.Descendants().First(e => e.Name.LocalName == "Version");
    var version = SemanticVersion.Parse(versionNode.Value);
    versionNode.Value = version.NextPatchVersion().ToString();

    var xws = new XmlWriterSettings { OmitXmlDeclaration = true, Indent = false, Encoding = encoding };
    using var writer = XmlWriter.Create(csprojPath, xws);
    doc.Save(writer);
    return 1;
}

return 0;

static async Task<(List<Data> entries, string fileUrl, string commit, DateTimeOffset commitDate)> LoadEntries()
{
    var token = Environment.GetEnvironmentVariable("GITHUB_TOKEN");
    if (token is null)
    {
        // gh auth token
        var process = Process.Start(new ProcessStartInfo
        {
            FileName = "gh",
            Arguments = "auth token",
            RedirectStandardOutput = true,
            UseShellExecute = false,
        });
        process!.WaitForExit();
        token = process.StandardOutput.ReadToEnd().Trim();
    }

    var jsonOptions = new JsonSerializerOptions
    {
        AllowTrailingCommas = true,
        ReadCommentHandling = JsonCommentHandling.Skip,
    };

    using var getCommitsRequest = new HttpRequestMessage(HttpMethod.Get, "https://api.github.com/repos/chromium/chromium/commits?path=net/http/transport_security_state_static.json&per_page=1");
    getCommitsRequest.Headers.UserAgent.Add(new ProductInfoHeaderValue("Meziantou.Framework.Http.Hsts.Generator", "1.0"));
    getCommitsRequest.Headers.Add("Authorization", "Bearer " + token);
    using var commitsResponse = await SharedHttpClient.Instance.SendAsync(getCommitsRequest);
    commitsResponse.EnsureSuccessStatusCode();
    var commits = await commitsResponse.Content.ReadFromJsonAsync<JsonDocument>(jsonOptions);
    var lastCommit = commits!.RootElement.EnumerateArray().First();
    var sha = lastCommit.GetProperty("sha").GetString()!;

    var commitDate = lastCommit.GetProperty("commit").GetProperty("committer").GetProperty("date").GetDateTimeOffset();
    var fileUrl = $"https://raw.githubusercontent.com/chromium/chromium/{sha}/net/http/transport_security_state_static.json";
    var content = await SharedHttpClient.Instance.GetFromJsonAsync<JsonDocument>(fileUrl, jsonOptions);
    if (content is null)
        throw new InvalidOperationException("The document is invalid");

    var entries = content.RootElement.GetProperty("entries").Deserialize<List<Data>>(jsonOptions);
    if (entries is null)
        throw new InvalidOperationException("The entries are invalid");

    // Remove entries that are not relevant
    entries.RemoveAll(entries => entries.Mode != "force-https" || entries.Policy == "test");

    // check if there are duplicated domains
    var duplicatedDomains = entries.GroupBy(e => e.Name, StringComparer.OrdinalIgnoreCase).Where(g => g.Count() > 1).Select(g => g.Key).ToList();
    if (duplicatedDomains.Count > 0)
        throw new InvalidOperationException("Duplicated domains: " + string.Join(", ", duplicatedDomains));

    return (entries, fileUrl, sha, commitDate);
}

internal sealed class Data
{
    [JsonPropertyName("name")]
    public required string Name { get; set; }

    [JsonPropertyName("policy")]
    public string? Policy { get; set; }

    [JsonPropertyName("mode")]
    public string? Mode { get; set; }

    [JsonPropertyName("include_subdomains")]
    public bool IncludeSubdomains { get; set; }

    public int SegmentCount => Name.Count(c => c == '.') + 1;
}
