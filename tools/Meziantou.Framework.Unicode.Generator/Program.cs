#pragma warning disable MA0004 // Use Task.ConfigureAwait
#pragma warning disable MA0047 // Declare types in namespaces
#pragma warning disable MA0048 // File name must match type name
using System.Globalization;
using System.Text;
using System.Xml;
using System.Xml.Linq;
using Meziantou.Framework;
using Meziantou.Framework.Versioning;

const string ConfusablesUrl = "https://www.unicode.org/Public/UCD/latest/security/confusables.txt";
const string UnicodeDataUrl = "https://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt";

if (!FullPath.CurrentDirectory().TryFindFirstAncestorOrSelf(path => Directory.Exists(path / ".git"), out var root))
    throw new InvalidOperationException("Cannot find git root from " + FullPath.CurrentDirectory());

var outputPath = root / "src" / "Meziantou.Framework.Unicode";
var outputFilePath = outputPath / "Unicode.Confusables.g.cs";
var unicodeDataPath = outputPath / "Resources" / "UnicodeData.bin.gz";
var obsoleteUnicodeDataPath = outputPath / "Resources" / "UnicodeData.bin";
var gitKeepPath = outputPath / "Resources" / ".gitkeep";
var csprojPath = root / "src" / "Meziantou.Framework.Unicode" / "Meziantou.Framework.Unicode.csproj";

Directory.CreateDirectory((outputPath / "Resources").Value);

var (confusableEntries, confusablesLastModified) = await LoadConfusablesEntries();
var unicodeDataEntries = await LoadUnicodeDataEntries();

var sb = new StringBuilder();
foreach (var entry in confusableEntries.OrderBy(entry => entry.Source.Value))
{
    sb.Append("            [new Rune(0x");
    sb.Append(entry.Source.Value.ToString("X", CultureInfo.InvariantCulture));
    sb.Append(")] = \"");
    sb.Append(EscapeString(entry.Target));
    sb.Append("\",\n");
}

var result = $$"""
    // <auto-generated />
    // Confusables data source: {{ConfusablesUrl}}
    // Last modified: {{confusablesLastModified}}

    #nullable enable

    using System.Collections.Generic;
    using System.Text;
    using System.Threading;

    namespace Meziantou.Framework;

    internal static class UnicodeConfusablesData
    {
        private static readonly Lazy<Dictionary<Rune, string>> Confusables = new(Create, LazyThreadSafetyMode.ExecutionAndPublication);

        public static bool TryGetReplacement(Rune rune, out string? replacement)
        {
            return Confusables.Value.TryGetValue(rune, out replacement);
        }

        private static Dictionary<Rune, string> Create()
        {
            return new Dictionary<Rune, string>(capacity: {{confusableEntries.Count}})
            {
    {{sb.ToString().TrimEnd('\n')}}
            };
        }
    }
    """.ReplaceLineEndings("\n");

var unicodeDataBytes = BuildUnicodeDataBinary(unicodeDataEntries);

var updated = false;
if (await WriteTextIfChanged(outputFilePath, result))
    updated = true;

if (WriteBinaryIfChanged(unicodeDataPath, unicodeDataBytes))
    updated = true;

if (TryDeleteFile(obsoleteUnicodeDataPath.Value))
    updated = true;

if (TryDeleteFile(gitKeepPath.Value))
    updated = true;

if (updated)
{
    var encoding = new UTF8Encoding(encoderShouldEmitUTF8Identifier: false);
    var doc = XDocument.Load(csprojPath, LoadOptions.PreserveWhitespace);
    var versionNode = doc.Descendants().First(e => e.Name.LocalName == "Version");
    var version = SemanticVersion.Parse(versionNode.Value);
    versionNode.Value = version.NextPatchVersion().ToString();

    var xws = new XmlWriterSettings { OmitXmlDeclaration = true, Indent = false, Encoding = encoding };
    using var writer = XmlWriter.Create(csprojPath, xws);
    doc.Save(writer);
    Console.WriteLine("The file has been updated");
    return 1;
}

return 0;

static async Task<(List<Entry> entries, string lastModified)> LoadConfusablesEntries()
{
    using var response = await SharedHttpClient.Instance.GetAsync(ConfusablesUrl);
    response.EnsureSuccessStatusCode();

    var lastModified = response.Content.Headers.LastModified?.ToString("O", CultureInfo.InvariantCulture) ?? "unknown";
    var content = await response.Content.ReadAsStringAsync();

    var entries = new Dictionary<Rune, Entry>();
    foreach (var rawLine in content.Split('\n'))
    {
        var line = rawLine.Trim();
        if (line.Length == 0 || line.StartsWith('#'))
            continue;

        var commentIndex = line.IndexOf('#', StringComparison.Ordinal);
        if (commentIndex >= 0)
        {
            line = line[..commentIndex].Trim();
        }

        if (line.Length == 0)
            continue;

        var parts = line.Split(';', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries);
        if (parts.Length < 2)
            continue;

        var source = ParseSingleRune(parts[0]);
        var target = ParseCodePointSequence(parts[1]);

        if (!entries.TryAdd(source, new Entry(source, target)))
            throw new InvalidOperationException("Duplicated source mapping: U+" + source.Value.ToString("X", CultureInfo.InvariantCulture));
    }

    return (entries.Values.ToList(), lastModified);
}

static async Task<List<UnicodeDataEntry>> LoadUnicodeDataEntries()
{
    using var response = await SharedHttpClient.Instance.GetAsync(UnicodeDataUrl);
    response.EnsureSuccessStatusCode();

    var content = await response.Content.ReadAsStringAsync();
    var entries = new List<UnicodeDataEntry>();
    PendingRange? pendingRange = null;

    foreach (var rawLine in content.Split('\n'))
    {
        var line = rawLine.Trim();
        if (line.Length == 0)
            continue;

        var fields = line.Split(';');
        if (fields.Length < 15)
            continue;

        var codePoint = int.Parse(fields[0], NumberStyles.HexNumber, CultureInfo.InvariantCulture);
        var name = fields[1];
        var category = ParseUnicodeCategory(fields[2]);
        var canonicalCombiningClass = byte.Parse(fields[3], NumberStyles.Integer, CultureInfo.InvariantCulture);
        var bidiCategory = ParseBidirectionalCategory(fields[4]);
        var decompositionMapping = NormalizeOptional(fields[5]);
        var decimalDigitValue = ParseSByteOrDefault(fields[6]);
        var digitValue = ParseSByteOrDefault(fields[7]);
        var numericValue = NormalizeOptional(fields[8]);
        var mirrored = fields[9] == "Y";
        var unicode1Name = NormalizeOptional(fields[10]);
        var isoComment = NormalizeOptional(fields[11]);
        var simpleUppercaseMapping = ParseHexOrDefault(fields[12]);
        var simpleLowercaseMapping = ParseHexOrDefault(fields[13]);
        var simpleTitlecaseMapping = ParseHexOrDefault(fields[14]);

        if (!Rune.TryCreate(codePoint, out var rune))
            continue;

        if (name.EndsWith(", First>", StringComparison.Ordinal))
        {
            var rangeName = NormalizeRangeName(name);
            pendingRange = new PendingRange(
                codePoint,
                new UnicodeDataEntry(
                    rune,
                    rangeName,
                    category,
                    bidiCategory,
                    canonicalCombiningClass,
                    decompositionMapping,
                    decimalDigitValue,
                    digitValue,
                    numericValue,
                    mirrored,
                    unicode1Name,
                    isoComment,
                    simpleUppercaseMapping,
                    simpleLowercaseMapping,
                    simpleTitlecaseMapping));
            continue;
        }

        if (name.EndsWith(", Last>", StringComparison.Ordinal))
        {
            if (pendingRange is null)
                throw new InvalidOperationException("UnicodeData range end without start: " + name);

            for (var value = pendingRange.Start; value <= codePoint; value++)
            {
                if (!Rune.TryCreate(value, out var rangeRune))
                    continue;

                entries.Add(pendingRange.Entry with { Rune = rangeRune });
            }

            pendingRange = null;
            continue;
        }

        entries.Add(new UnicodeDataEntry(
            rune,
            name,
            category,
            bidiCategory,
            canonicalCombiningClass,
            decompositionMapping,
            decimalDigitValue,
            digitValue,
            numericValue,
            mirrored,
            unicode1Name,
            isoComment,
            simpleUppercaseMapping,
            simpleLowercaseMapping,
            simpleTitlecaseMapping));
    }

    if (pendingRange is not null)
        throw new InvalidOperationException("UnicodeData range start without end: " + pendingRange.Entry.Name);

    return entries;
}

static string ParseCodePointSequence(string input)
{
    var sb = new StringBuilder();
    foreach (var token in input.Split(' ', StringSplitOptions.RemoveEmptyEntries))
    {
        var value = int.Parse(token, NumberStyles.HexNumber, CultureInfo.InvariantCulture);
        sb.Append(char.ConvertFromUtf32(value));
    }

    return sb.ToString();
}

static Rune ParseSingleRune(string input)
{
    var tokens = input.Split(' ', StringSplitOptions.RemoveEmptyEntries);
    if (tokens.Length != 1)
        throw new InvalidOperationException("Source is not a single rune: " + input);

    var value = int.Parse(tokens[0], NumberStyles.HexNumber, CultureInfo.InvariantCulture);
    return new Rune(value);
}

static string EscapeString(string value)
{
    var sb = new StringBuilder();
    foreach (var rune in value.EnumerateRunes())
    {
        var scalar = rune.Value;
        if (scalar <= 0xFFFF)
        {
            sb.Append("\\u");
            sb.Append(scalar.ToString("X4", CultureInfo.InvariantCulture));
        }
        else
        {
            sb.Append("\\U");
            sb.Append(scalar.ToString("X8", CultureInfo.InvariantCulture));
        }
    }

    return sb.ToString();
}

static byte[] BuildUnicodeDataBinary(List<UnicodeDataEntry> entries)
{
    var stringIndex = new Dictionary<string, int>(StringComparer.Ordinal);
    var strings = new List<string>();
    var serialized = new List<SerializedUnicodeDataEntry>(entries.Count);

    foreach (var entry in entries)
    {
        serialized.Add(new SerializedUnicodeDataEntry(
            entry.Rune.Value,
            GetStringIndex(entry.Name),
            entry.Category,
            entry.BidiCategory,
            entry.CanonicalCombiningClass,
            GetStringIndex(entry.DecompositionMapping),
            entry.DecimalDigitValue,
            entry.DigitValue,
            GetStringIndex(entry.NumericValue),
            entry.Mirrored,
            GetStringIndex(entry.Unicode1Name),
            GetStringIndex(entry.IsoComment),
            entry.SimpleUppercaseMapping,
            entry.SimpleLowercaseMapping,
            entry.SimpleTitlecaseMapping));
    }

    using var stream = new MemoryStream();
    using var writer = new BinaryWriter(stream, Encoding.UTF8, leaveOpen: true);

    writer.Write(new byte[] { (byte)'U', (byte)'C', (byte)'D', (byte)'1' });
    writer.Write(1);
    writer.Write(serialized.Count);
    writer.Write(strings.Count);

    foreach (var value in strings)
    {
        WriteUtf8String(stream, value);
    }

    foreach (var entry in serialized.OrderBy(entry => entry.RuneValue))
    {
        writer.Write(entry.RuneValue);
        writer.Write(entry.NameIndex);
        writer.Write((byte)entry.Category);
        writer.Write((byte)entry.BidiCategory);
        writer.Write(entry.CanonicalCombiningClass);
        writer.Write(entry.DecompositionIndex);
        writer.Write(entry.DecimalDigitValue);
        writer.Write(entry.DigitValue);
        writer.Write(entry.NumericIndex);
        writer.Write(entry.Mirrored ? (byte)1 : (byte)0);
        writer.Write(entry.Unicode1NameIndex);
        writer.Write(entry.IsoCommentIndex);
        writer.Write(entry.SimpleUppercaseMapping);
        writer.Write(entry.SimpleLowercaseMapping);
        writer.Write(entry.SimpleTitlecaseMapping);
    }

    writer.Flush();
    stream.Position = 0;

    using var compressed = new MemoryStream();
    using (var gzip = new System.IO.Compression.GZipStream(compressed, System.IO.Compression.CompressionLevel.SmallestSize, leaveOpen: true))
    {
        stream.CopyTo(gzip);
    }

    return compressed.ToArray();

    int GetStringIndex(string? value)
    {
        if (string.IsNullOrEmpty(value))
            return -1;

        if (!stringIndex.TryGetValue(value, out var index))
        {
            index = strings.Count;
            strings.Add(value);
            stringIndex.Add(value, index);
        }

        return index;
    }
}

static bool WriteBinaryIfChanged(string filePath, byte[] content)
{
    if (File.Exists(filePath))
    {
        var existing = File.ReadAllBytes(filePath);
        if (existing.AsSpan().SequenceEqual(content))
            return false;
    }

    File.WriteAllBytes(filePath, content);
    return true;
}

static bool TryDeleteFile(string filePath)
{
    if (!File.Exists(filePath))
        return false;

    File.Delete(filePath);
    return true;
}

static async Task<bool> WriteTextIfChanged(string filePath, string content)
{
    if (File.Exists(filePath) && (await File.ReadAllTextAsync(filePath)).ReplaceLineEndings("\n") == content)
        return false;

    var encoding = new UTF8Encoding(encoderShouldEmitUTF8Identifier: false);
    await File.WriteAllTextAsync(filePath, content, encoding);
    return true;
}

static string NormalizeRangeName(string name)
{
    return name.Replace(", First>", ">", StringComparison.Ordinal)
        .Replace(", Last>", ">", StringComparison.Ordinal);
}

static string? NormalizeOptional(string value)
{
    return string.IsNullOrEmpty(value) ? null : value;
}

static int ParseHexOrDefault(string value)
{
    return string.IsNullOrEmpty(value)
        ? -1
        : int.Parse(value, NumberStyles.HexNumber, CultureInfo.InvariantCulture);
}

static sbyte ParseSByteOrDefault(string value)
{
    return string.IsNullOrEmpty(value)
        ? (sbyte)-1
        : sbyte.Parse(value, NumberStyles.Integer, CultureInfo.InvariantCulture);
}

static UnicodeCategory ParseUnicodeCategory(string value)
{
    return value switch
    {
        "Lu" => UnicodeCategory.UppercaseLetter,
        "Ll" => UnicodeCategory.LowercaseLetter,
        "Lt" => UnicodeCategory.TitlecaseLetter,
        "Lm" => UnicodeCategory.ModifierLetter,
        "Lo" => UnicodeCategory.OtherLetter,
        "Mn" => UnicodeCategory.NonSpacingMark,
        "Mc" => UnicodeCategory.SpacingCombiningMark,
        "Me" => UnicodeCategory.EnclosingMark,
        "Nd" => UnicodeCategory.DecimalDigitNumber,
        "Nl" => UnicodeCategory.LetterNumber,
        "No" => UnicodeCategory.OtherNumber,
        "Pc" => UnicodeCategory.ConnectorPunctuation,
        "Pd" => UnicodeCategory.DashPunctuation,
        "Ps" => UnicodeCategory.OpenPunctuation,
        "Pe" => UnicodeCategory.ClosePunctuation,
        "Pi" => UnicodeCategory.InitialQuotePunctuation,
        "Pf" => UnicodeCategory.FinalQuotePunctuation,
        "Po" => UnicodeCategory.OtherPunctuation,
        "Sm" => UnicodeCategory.MathSymbol,
        "Sc" => UnicodeCategory.CurrencySymbol,
        "Sk" => UnicodeCategory.ModifierSymbol,
        "So" => UnicodeCategory.OtherSymbol,
        "Zs" => UnicodeCategory.SpaceSeparator,
        "Zl" => UnicodeCategory.LineSeparator,
        "Zp" => UnicodeCategory.ParagraphSeparator,
        "Cc" => UnicodeCategory.Control,
        "Cf" => UnicodeCategory.Format,
        "Cs" => UnicodeCategory.Surrogate,
        "Co" => UnicodeCategory.PrivateUse,
        "Cn" => UnicodeCategory.OtherNotAssigned,
        _ => throw new InvalidOperationException("Unknown Unicode category: " + value),
    };
}

static UnicodeBidirectionalCategory ParseBidirectionalCategory(string value)
{
    return value switch
    {
        "L" => UnicodeBidirectionalCategory.LeftToRight,
        "R" => UnicodeBidirectionalCategory.RightToLeft,
        "AL" => UnicodeBidirectionalCategory.RightToLeftArabic,
        "EN" => UnicodeBidirectionalCategory.EuropeanNumber,
        "ES" => UnicodeBidirectionalCategory.EuropeanSeparator,
        "ET" => UnicodeBidirectionalCategory.EuropeanTerminator,
        "AN" => UnicodeBidirectionalCategory.ArabicNumber,
        "CS" => UnicodeBidirectionalCategory.CommonSeparator,
        "B" => UnicodeBidirectionalCategory.ParagraphSeparator,
        "S" => UnicodeBidirectionalCategory.SegmentSeparator,
        "WS" => UnicodeBidirectionalCategory.WhiteSpace,
        "ON" => UnicodeBidirectionalCategory.OtherNeutral,
        "NSM" => UnicodeBidirectionalCategory.NonspacingMark,
        "LRE" => UnicodeBidirectionalCategory.LeftToRightEmbedding,
        "LRO" => UnicodeBidirectionalCategory.LeftToRightOverride,
        "RLE" => UnicodeBidirectionalCategory.RightToLeftEmbedding,
        "RLO" => UnicodeBidirectionalCategory.RightToLeftOverride,
        "PDF" => UnicodeBidirectionalCategory.PopDirectionalFormat,
        "LRI" => UnicodeBidirectionalCategory.LeftToRightIsolate,
        "RLI" => UnicodeBidirectionalCategory.RightToLeftIsolate,
        "FSI" => UnicodeBidirectionalCategory.FirstStrongIsolate,
        "PDI" => UnicodeBidirectionalCategory.PopDirectionalIsolate,
        "BN" => UnicodeBidirectionalCategory.BoundaryNeutral,
        _ => throw new InvalidOperationException("Unknown bidirectional category: " + value),
    };
}

static void WriteUtf8String(Stream stream, string value)
{
    var bytes = Encoding.UTF8.GetBytes(value);
    Write7BitEncodedInt(stream, bytes.Length);
    stream.Write(bytes, 0, bytes.Length);
}

static void Write7BitEncodedInt(Stream stream, int value)
{
    var uValue = (uint)value;
    while (uValue >= 0x80)
    {
        stream.WriteByte((byte)(uValue | 0x80));
        uValue >>= 7;
    }

    stream.WriteByte((byte)uValue);
}

internal sealed record Entry(Rune Source, string Target);

internal enum UnicodeBidirectionalCategory : byte
{
    LeftToRight,
    RightToLeft,
    RightToLeftArabic,
    EuropeanNumber,
    EuropeanSeparator,
    EuropeanTerminator,
    ArabicNumber,
    CommonSeparator,
    ParagraphSeparator,
    SegmentSeparator,
    WhiteSpace,
    OtherNeutral,
    NonspacingMark,
    LeftToRightEmbedding,
    LeftToRightOverride,
    RightToLeftEmbedding,
    RightToLeftOverride,
    PopDirectionalFormat,
    LeftToRightIsolate,
    RightToLeftIsolate,
    FirstStrongIsolate,
    PopDirectionalIsolate,
    BoundaryNeutral,
}

internal sealed record PendingRange(int Start, UnicodeDataEntry Entry);

internal sealed record UnicodeDataEntry(
    Rune Rune,
    string Name,
    UnicodeCategory Category,
    UnicodeBidirectionalCategory BidiCategory,
    byte CanonicalCombiningClass,
    string? DecompositionMapping,
    sbyte DecimalDigitValue,
    sbyte DigitValue,
    string? NumericValue,
    bool Mirrored,
    string? Unicode1Name,
    string? IsoComment,
    int SimpleUppercaseMapping,
    int SimpleLowercaseMapping,
    int SimpleTitlecaseMapping);

internal sealed record SerializedUnicodeDataEntry(
    int RuneValue,
    int NameIndex,
    UnicodeCategory Category,
    UnicodeBidirectionalCategory BidiCategory,
    byte CanonicalCombiningClass,
    int DecompositionIndex,
    sbyte DecimalDigitValue,
    sbyte DigitValue,
    int NumericIndex,
    bool Mirrored,
    int Unicode1NameIndex,
    int IsoCommentIndex,
    int SimpleUppercaseMapping,
    int SimpleLowercaseMapping,
    int SimpleTitlecaseMapping);
