#pragma warning disable MA0004 // Use Task.ConfigureAwait
#pragma warning disable MA0047 // Declare types in namespaces
#pragma warning disable MA0048 // File name must match type name
using System.Xml;
using System.Xml.Linq;
using Meziantou.Framework;
using Meziantou.Framework.Versioning;

const string ConfusablesUrl = "https://www.unicode.org/Public/UCD/latest/security/confusables.txt";

if (!FullPath.CurrentDirectory().TryFindFirstAncestorOrSelf(path => Directory.Exists(path / ".git"), out var root))
    throw new InvalidOperationException("Cannot find git root from " + FullPath.CurrentDirectory());

var outputPath = root / "src" / "Meziantou.Framework.Unicode";
var outputFilePath = outputPath / "Unicode.Confusables.g.cs";
var csprojPath = root / "src" / "Meziantou.Framework.Unicode" / "Meziantou.Framework.Unicode.csproj";

var (entries, lastModified) = await LoadEntries();

var sb = new StringBuilder();
foreach (var entry in entries.OrderBy(entry => entry.Source.Value))
{
    sb.Append("            [new Rune(0x");
    sb.Append(entry.Source.Value.ToString("X", CultureInfo.InvariantCulture));
    sb.Append(")] = \"");
    sb.Append(EscapeString(entry.Target));
    sb.Append("\",\n");
}

var result = $$"""
    // <auto-generated />
    // Confusables data source: {{ConfusablesUrl}}
    // Last modified: {{lastModified}}

    #nullable enable

    using System.Collections.Generic;
    using System.Text;
    using System.Threading;

    namespace Meziantou.Framework;

    internal static class UnicodeConfusablesData
    {
        private static readonly Lazy<Dictionary<Rune, string>> Confusables = new(Create, LazyThreadSafetyMode.ExecutionAndPublication);

        public static bool TryGetReplacement(Rune rune, out string? replacement)
        {
            return Confusables.Value.TryGetValue(rune, out replacement);
        }

        private static Dictionary<Rune, string> Create()
        {
            return new Dictionary<Rune, string>
            {
    {{sb.ToString().TrimEnd('\n')}}
            };
        }
    }
    """.ReplaceLineEndings("\n");

if (!File.Exists(outputFilePath) || (await File.ReadAllTextAsync(outputFilePath)).ReplaceLineEndings("\n") != result)
{
    var encoding = new UTF8Encoding(encoderShouldEmitUTF8Identifier: false);
    await File.WriteAllTextAsync(outputFilePath, result, encoding);
    Console.WriteLine("The file has been updated");

    var doc = XDocument.Load(csprojPath, LoadOptions.PreserveWhitespace);
    var versionNode = doc.Descendants().First(e => e.Name.LocalName == "Version");
    var version = SemanticVersion.Parse(versionNode.Value);
    versionNode.Value = version.NextPatchVersion().ToString();

    var xws = new XmlWriterSettings { OmitXmlDeclaration = true, Indent = false, Encoding = encoding };
    using var writer = XmlWriter.Create(csprojPath, xws);
    doc.Save(writer);
    return 1;
}

return 0;

static async Task<(List<Entry> entries, string lastModified)> LoadEntries()
{
    using var response = await SharedHttpClient.Instance.GetAsync(ConfusablesUrl);
    response.EnsureSuccessStatusCode();

    var lastModified = response.Content.Headers.LastModified?.ToString("O", CultureInfo.InvariantCulture) ?? "unknown";
    var content = await response.Content.ReadAsStringAsync();

    var entries = new Dictionary<Rune, Entry>();
    foreach (var rawLine in content.Split('\n'))
    {
        var line = rawLine.Trim();
        if (line.Length == 0 || line.StartsWith('#'))
            continue;

        var commentIndex = line.IndexOf('#', StringComparison.Ordinal);
        if (commentIndex >= 0)
        {
            line = line[..commentIndex].Trim();
        }

        if (line.Length == 0)
            continue;

        var parts = line.Split(';', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries);
        if (parts.Length < 2)
            continue;

        var source = ParseSingleRune(parts[0]);
        var target = ParseCodePointSequence(parts[1]);

        if (!entries.TryAdd(source, new Entry(source, target)))
            throw new InvalidOperationException("Duplicated source mapping: U+" + source.Value.ToString("X", CultureInfo.InvariantCulture));
    }

    return (entries.Values.ToList(), lastModified);
}

static string ParseCodePointSequence(string input)
{
    var sb = new StringBuilder();
    foreach (var token in input.Split(' ', StringSplitOptions.RemoveEmptyEntries))
    {
        var value = int.Parse(token, NumberStyles.HexNumber, CultureInfo.InvariantCulture);
        sb.Append(char.ConvertFromUtf32(value));
    }

    return sb.ToString();
}

static Rune ParseSingleRune(string input)
{
    var tokens = input.Split(' ', StringSplitOptions.RemoveEmptyEntries);
    if (tokens.Length != 1)
        throw new InvalidOperationException("Source is not a single rune: " + input);

    var value = int.Parse(tokens[0], NumberStyles.HexNumber, CultureInfo.InvariantCulture);
    return new Rune(value);
}

static string EscapeString(string value)
{
    var sb = new StringBuilder();
    foreach (var rune in value.EnumerateRunes())
    {
        var scalar = rune.Value;
        if (scalar <= 0xFFFF)
        {
            sb.Append("\\u");
            sb.Append(scalar.ToString("X4", CultureInfo.InvariantCulture));
        }
        else
        {
            sb.Append("\\U");
            sb.Append(scalar.ToString("X8", CultureInfo.InvariantCulture));
        }
    }

    return sb.ToString();
}

internal sealed record Entry(Rune Source, string Target);
